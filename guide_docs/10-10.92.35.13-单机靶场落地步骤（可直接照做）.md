# 10.92.35.13 单机靶场落地步骤（可直接照做）

适用对象：你只有一台内网 Ubuntu 主机（`10.92.35.13`），你负责“靶场搭建”。目标是在单机上搭出 **≥5 节点**（中心机 + 4×客户机 + C2）并保证**可观测、可复现**。

本文只覆盖“靶场底座”。中心机轮询客户机 `/api/v1/pull`、攻击链生成等业务接口尚未完全接线时，也不影响你把网络/采集/证据底座交付出来。

---

## 0. 你要达到的最终状态（验收口径）

### 0.1 节点（逻辑节点）

- `center-01`：OpenSearch + Neo4j（可选再跑后端/前端）
- `client-01..04`：4 套客户机采集栈（Falco/Filebeat/Suricata → SQLite → Client API）
- `c2-01`：DNS + HTTP（建议独立 IP：`10.92.35.50`）

> 这就是 1 + 4 + 1 = 6 节点（≥5）。

### 0.2 必须能证明的东西

- 端口可达：中心机端口、每个 client 的 API 端口、c2 的 DNS/HTTP
- client 数据可增长：每个实例的 SQLite（`data.db`）在增长
- 证据可观测：对 `c2.lab.local` 发起 DNS/HTTP 请求后：
  - c2 有访问日志
  - **在宿主机 `macvlan0` 上**能抓到到 `10.92.35.50:53`、`10.92.35.51:80` 的流量（macvlan 方案）

---

## 1. 前置：确认本机条件

在 `10.92.35.13` 上执行：

```bash
ip -br a
ip route
docker --version
docker-compose --version || true
```

你之前输出显示：

- 网卡：`ens5f1`（有内网 IP）
- Docker 可用
- `docker compose` v2 不可用，但 `docker-compose` v1 可用

本文命令默认用 **`docker-compose`**（v1）。

---

## 2. 目录规划（强烈建议照做，后面排障会省很多时间）

建议统一用家目录，避免 sudo 与权限坑。本文后续用一个变量表示根目录：

```bash
export BASE=/home/ubuntu/attack-trace-analyzer
```

在宿主机上准备根目录（示例）：

```bash
mkdir -p "$BASE"/{repo,run}
```

目录结构建议如下：

- `$BASE/repo/attack-trace-analyzer/`（项目代码）
- `$BASE/run/`
  - `client-01/data/`
  - `client-02/data/`
  - `client-03/data/`
  - `client-04/data/`
  - `c2/`

---

## 3. 部署中心机基础设施（OpenSearch + Neo4j）

在代码仓库机器上（假设你已把仓库放到 `$BASE/repo/attack-trace-analyzer/`）：

```bash
cd "$BASE"/repo/attack-trace-analyzer/backend
docker-compose up -d
```

验证端口监听（至少本机）：

```bash
ss -lntup | egrep ':(9200|9600|7474|7687)\b' || true
```

验证 Neo4j（浏览器）：

- `http://10.92.35.13:7474`

验证 OpenSearch（HTTPS，自签名）：

```bash
curl -k -s https://10.92.35.13:9200 >/dev/null && echo "opensearch ok"
```

> 如果 OpenSearch 报 `vm.max_map_count` 相关错误，按提示把 `vm.max_map_count` 调大（这是 ES/OS 常规要求）。

---

## 4. 部署 c2-01（DNS + HTTP，macvlan 优先）

### 4.1 先选 C2 独立 IP

建议使用 **两个 IP**（更稳）：  

- DNS：`10.92.35.50`  
- HTTP：`10.92.35.51`

（确保都没被占用）

```bash
ping -c 1 10.92.35.50 || true
ping -c 1 10.92.35.51 || true
```

### 4.2 关键说明：host ↔ macvlan 容器默认不互通

Linux 的一个常见坑：macvlan 网络下，宿主机默认无法直接访问 macvlan 容器的 IP。

解决办法：在宿主机上创建一个 macvlan 子接口（例如 `macvlan0`）并分配一个同网段 IP。

> 下面步骤是“靶场可观测性”的核心，建议你严格照做。

### 4.3 创建 macvlan 网络（Docker）

> 注意：这会在你的物理网卡 `ens5f1` 上创建一个 L2 网络承载。

```bash
sudo docker network create -d macvlan \
  --subnet=10.92.35.0/24 \
  --gateway=10.92.35.254 \
  -o parent=ens5f1 \
  c2-macvlan
```

### 4.4 让宿主机能访问 macvlan（创建 macvlan0）

选择一个宿主机用的 macvlan IP（不要和 C2 冲突），例如：`10.92.35.60`

```bash
sudo ip link add macvlan0 link ens5f1 type macvlan mode bridge
sudo ip addr add 10.92.35.60/24 dev macvlan0
sudo ip link set macvlan0 up
```

关键：macvlan 有“宿主机与同 parent 下 macvlan 子口隔离”的特性。为了让宿主机能访问 `10.92.35.50/51`，需要显式把这两个 IP 的路由指到 `macvlan0`：

```bash
sudo ip route add 10.92.35.50/32 dev macvlan0 || true
sudo ip route add 10.92.35.51/32 dev macvlan0 || true
```

### 4.5 准备 C2 的 DNS 与 HTTP（两容器）

你在 `run/c2/` 下准备两个配置概念：

- CoreDNS：解析 `c2.lab.local -> 10.92.35.51`（HTTP 节点）
- HTTP：提供 `/health` 与 `/payload`

你可以先用最简单策略：HTTP 用 nginx（默认页面也行），DNS 用 CoreDNS（最小 A 记录）。

> 这里我给“可直接复制粘贴”的文件内容，你按路径创建即可。

#### A) CoreDNS：`Corefile`

路径：`$BASE/run/c2/Corefile`

内容：

```txt
.:53 {
  log
  errors
  hosts /etc/coredns/hosts {
    reload 1s
    fallthrough
  }
  forward . 223.5.5.5 114.114.114.114
}
```

#### B) CoreDNS：hosts 记录

路径：`$BASE/run/c2/hosts`

内容：

```txt
10.92.35.51 c2.lab.local
```

#### C) HTTP：nginx 静态页

路径：`$BASE/run/c2/html/health`

内容：

```txt
ok
```

路径：`$BASE/run/c2/html/payload`

内容：

```txt
hello from c2 (benign)
```

并创建目录：

```bash
mkdir -p "$BASE"/run/c2/html
```

### 4.6 启动 c2-01（连接到 macvlan，并绑定 IP）

启动 DNS（CoreDNS）：

```bash
docker run -d --name c2-dns \
  --network c2-macvlan --ip 10.92.35.50 \
  -v "$BASE"/run/c2/Corefile:/etc/coredns/Corefile:ro \
  -v "$BASE"/run/c2/hosts:/etc/coredns/hosts:ro \
  coredns/coredns:latest
```

启动 HTTP（nginx）：

```bash
docker run -d --name c2-http \
  --network c2-macvlan --ip 10.92.35.51 \
  -v "$BASE"/run/c2/html:/usr/share/nginx/html:ro \
  nginx:latest
```

说明：DNS 与 HTTP 使用不同 IP，避免 “Address already in use”。

### 4.7 验证 c2-01

从宿主机验证 DNS（走你刚建的 macvlan0）：

```bash
dig @10.92.35.50 c2.lab.local +short
```

从宿主机验证 HTTP：

```bash
curl -s http://10.92.35.51/health && echo
curl -s http://10.92.35.51/payload && echo
```

从宿主机抓包验证可观测性（关键）：

```bash
# 注意：
# 你已经把 10.92.35.50/51 的 /32 路由指到 macvlan0，因此宿主机访问 c2 时流量会走 macvlan0；
# 这类流量未必会出现在 ens5f1 抓包结果里（所以在 ens5f1 上可能看到 0 包）。
#
# 推荐抓 macvlan0（最稳定）：
sudo tcpdump -i macvlan0 -nn -c 20 'host 10.92.35.50 or host 10.92.35.51'
#
# 如果你想“一条命令”同时完成抓包+发请求（避免时机问题）：
sudo timeout 3 tcpdump -i macvlan0 -nn '(host 10.92.35.50 and (udp port 53 or tcp port 53)) or (host 10.92.35.51 and tcp port 80)' &
sleep 0.2
dig @10.92.35.50 c2.lab.local +noall +answer +time=1 +tries=1
curl -s http://10.92.35.51/health && echo
wait
```

---

## 5. 部署 4 套 client（单机多实例）

你们 client 已经有 `client/docker-compose.yml`，但默认端口（8888/8080）会冲突。你需要做到：

- 每个实例不同宿主端口：18881..18884、18081..18084
- 每个实例不同 `HOST_ID/HOST_NAME`
- 每个实例不同数据目录挂载（独立 `data.db`）

### 5.1 推荐方式（最稳）：复制 4 份运行目录（不复制代码，只复制 compose + data）

准备 4 个实例目录：

```bash
mkdir -p "$BASE"/run/client-{01,02,03,04}/data
```

在每个实例目录里放一份 `docker-compose.yml`（从仓库 `client/docker-compose.yml` 复制过来），然后修改：

- `ports:` 映射（backend 8888 与 exporter 8080）
- `HOST_ID/HOST_NAME`
- `SURICATA_INTERFACE=ens5f1`

⚠️ 重要：你只复制 `docker-compose.yml` 的话，里面的 `build.context: ./sensor/...`、`./backend` 等相对路径在 `run/client-01/` 下会找不到源码目录，导致 `docker-compose up --build` 报错。

最省事的解决方式：在每个 `run/client-0X/` 下创建两个软链接，让相对路径成立：

```bash
cd "$BASE"/run/client-01
ln -s "$BASE"/repo/attack-trace-analyzer/client/sensor sensor
ln -s "$BASE"/repo/attack-trace-analyzer/client/backend backend
```

（client-02/03/04 同理，只是目录不同。）

> 这一步是纯配置工程，最适合靶场负责人做。你做完一次，后面永远复用。

### 5.2 重要修正：必须去掉 `container_name`（否则无法启动多实例）

如果你的 `docker-compose ps` 里看到容器名字是固定的（例如 `backend` / `falco` / `filebeat` / `falco-ecs`），说明 compose 文件里存在 `container_name:`。

这会导致你启动 `client-02` 时**必然报错**（容器名已被占用）。

处理方式（对每个实例的 `docker-compose.yml` 都做一次）：

- 打开 `"$BASE/run/client-01/docker-compose.yml"`（以及 `client-02/03/04` 的同名文件）
- **删除所有 `container_name:` 行**
- 然后在该实例目录执行：

```bash
cd "$BASE"/run/client-01
docker-compose down
docker-compose up -d --build
```

> 说明：这里用的是 bind mount（`./data:/data`），`docker-compose down` 不会删除你目录下的 `data.db` 等文件。

### 5.3 每个 client 实例的最小验证

以 client-01 为例（假设你映射到 `18881`）：

```bash
curl -s http://10.92.35.13:18881/filebeat | head
curl -s http://10.92.35.13:18881/falco | head
curl -s http://10.92.35.13:18881/suricata | head
```

如果 `total` 随时间增长，就说明采集链路活着。

### 5.4 扩到 4 个实例（端口与 HOST 标识）

按同样方式准备：

- `"$BASE/run/client-02"`：`18882/18082`，`HOST_ID=h-client-02`，`HOST_NAME=victim-02`
- `"$BASE/run/client-03"`：`18883/18083`，`HOST_ID=h-client-03`，`HOST_NAME=victim-03`
- `"$BASE/run/client-04"`：`18884/18084`，`HOST_ID=h-client-04`，`HOST_NAME=victim-04`

> 提示：在“单机多节点”方案里，多套 Suricata 抓同一块网卡会看到相似流量；多套 Filebeat 也会重复采集宿主日志。若你发现资源压力增大，可先让 `client-02..04` 只跑 Falco+Suricata（保留 1 套 Filebeat 作为主机日志来源），这不影响你完成靶场搭建交付。

---

## 6. 做一次“安全动作 → 证据”验收（你交付靶场必须要有）

### 6.1 产生 DNS/HTTP 证据（指向 c2.lab.local）

在宿主机上执行（或在任意 client 实例相关环境里执行）：

```bash
dig @10.92.35.50 c2.lab.local
curl -s http://10.92.35.51/health
```

然后：

- **推荐**：`tcpdump -i macvlan0 host 10.92.35.50` / `host 10.92.35.51` 能看到包  
  （你已经把 `10.92.35.50/51` 的 `/32` 路由指到 `macvlan0`，因此宿主机发往 C2 的流量会走 `macvlan0`；在 `ens5f1` 上抓到 0 包是正常现象）
- 任意一个 client 的 `/suricata` 接口 `total` 应增加（或至少 suricata 表增长）

### 6.2 产生主机日志/行为证据

最安全的方式：

- 做一次 SSH 登录（如果你没有第二台机器，就同机不同用户/不同端口制造差异）
- 在 `/tmp` 下做文件创建/读写/删除

然后：

- client 的 `/filebeat`、`/falco` 的 `total` 应增加

---

## 7. 你交付给组内/老师的材料建议（靶场负责人专属）

请准备以下截图/输出（演示时很省事）：

- `ip -br a` + `ip route`（证明网络与网卡）
- `ss -lntup`（证明端口规划）
- `dig @10.92.35.50 c2.lab.local +short`（证明 DNS）
- `curl http://10.92.35.51/health`（证明 HTTP）
- **推荐**：`tcpdump -i macvlan0 host 10.92.35.50` 与 `host 10.92.35.51`（证明可观测性）
- 任意一个 client 的三接口返回里 `total` 前后对比（证明采集活着）

---

## 8. 如果你卡住了，去看哪里

- 总体方案与取舍：`01-靶场总体方案（单机多节点）.md`
- c2 的原理与 macvlan 必要性：`03-c2-01-DNS+HTTP（macvlan优先）.md`
- 验收检查点：`04-验证清单（网络-采集-证据）.md`
- 重置/排障：`05-重置复现与排障.md`

