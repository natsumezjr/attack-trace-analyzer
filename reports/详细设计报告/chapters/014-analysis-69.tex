\subsection{KillChain 概览设计}\label{killchain-overview}

\subsection{KillChain 的定位与目标}\label{killchain-positioning}

\subsubsection{定位}\label{killchain-position}

KillChain 作为 Analysis 模块溯源任务的核心算法实现，承担攻击路径重建与可解释性报告生成的双重职责。

\subsubsection{目标}\label{killchain-objectives}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{战术分段}：依据 MITRE ATT\&CK 战术分类，自动划分攻击事件阶段
\item
  \textbf{路径重建}：识别并连接各战术阶段间的过渡路径
\item
  \textbf{智能选择}：借助大语言模型（LLM）甄选最合理的攻击链路
\item
  \textbf{可解释性}：生成 10-20 句中文的全链解释，采用主谓宾结构增强可读性
\item
  \textbf{置信度评估}：输出可信度评分（0.0-1.0），量化分析结果可靠性
\end{enumerate}

\subsubsection{与溯源任务的关系}\label{killchain-trace-task}

\begin{verbatim}
溯源任务 (Trace Task)
    │
    ├─→ TTP 相似度匹配 (组织归因)
    │
    └─→ KillChain 分析 (路径重建 + 解释生成)
\end{verbatim}

\begin{itemize}
\tightlist
\item
  \textbf{溯源任务}：由前端触发的异步任务容器
\item
  \textbf{TTP 相似度}：基于 Canonical Findings 计算与 APT 组织的相似度
\item
  \textbf{KillChain}：利用图谱数据重建攻击路径并生成解释
\end{itemize}

两者相辅相成，共同构建完整的溯源分析体系。

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{基于 MITRE ATT\&CK 战术的分段机制}\label{killchain-mitre-tactics}

\subsubsection{AttackState 枚举}\label{killchain-attackstate}

系统采用有限状态自动机（FSA）识别攻击阶段，状态枚举定义如下：

{\def\LTcaptype{none} % do not increment counter
\footnotesize
\begin{longtable}[]{@{}p{0.25\textwidth}p{0.12\textwidth}p{0.53\textwidth}@{}}
\toprule\noalign{}
状态值 & MITRE ATT\&CK 战术 & 说明 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\texttt{INITIAL\_ACCESS} & TA0001 Initial Access & 初始入侵 \\
\texttt{EXECUTION} & TA0002 Execution & 执行 \\
\texttt{PRIVILEGE\_ESCALATION} & TA0004 Privilege Escalation & 权限提升 \\
\texttt{LATERAL\_MOVEMENT} & TA0008 Lateral Movement & 横向移动 \\
\texttt{COMMAND\_AND\_CONTROL} & TA0011 Command and Control & 命令与控制 \\
\texttt{DISCOVERY} & TA0007 Discovery & 发现 \\
\texttt{IMPACT} & TA0040 Impact & 影响 \\
\end{longtable}
}

实现绑定点：

\begin{itemize}
\tightlist
\item
  状态定义：\texttt{backend/app/services/analyze/killchain.py:AttackState}
\item
  状态转换规则：\texttt{backend/app/services/analyze/killchain.py:FSABuilder}
\end{itemize}

\subsubsection{StateSegment 结构}\label{killchain-statesegment}

每个战术阶段（Segment）由以下字段构成：

\begin{itemize}
\tightlist
\item
  \texttt{seg\_idx:\ int} - 段索引
\item
  \texttt{state:\ AttackState} - 战术状态
\item
  \texttt{t\_start:\ float} - 段起始时间（Unix 时间戳）
\item
  \texttt{t\_end:\ float} - 段结束时间（Unix 时间戳）
\item
  \texttt{anchor\_in\_uid:\ str} - 段入口锚点节点 UID
\item
  \texttt{anchor\_out\_uid:\ str} - 段出口锚点节点 UID
\item
  \texttt{abnormal\_edge\_summaries:\ list{[}dict{]}} - 段内 top 6 异常边摘要
\end{itemize}

\subsubsection{分段生成规则}\label{killchain-segment-generation}

分段生成遵循以下规则：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  起始于告警边集合（\texttt{is\_alarm=true}）
\item
  依据 \texttt{threat.tactic.id} 将边分组至对应战术状态
\item
  按时间顺序对各战术状态的边进行排序
\item
  为每个战术状态生成 Segment，并确定入口/出口锚点
\item
  计算各 Segment 的时间跨度（\texttt{t\_start}, \texttt{t\_end}）
\item
  从每个 Segment 中筛选 top 6 异常边作为摘要
\end{enumerate}

实现绑定点：

\begin{itemize}
\tightlist
\item
  FSA 构建：\texttt{backend/app/services/analyze/killchain.py:build\_fsa\_graph()}
\item
  段摘要生成：\texttt{backend/app/services/analyze/killchain.py:summarize\_edge()}
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{数据结构概览}\label{killchain-data-structures}

\subsubsection{KillChain 核心数据结构}\label{killchain-class}

\begin{verbatim}
@dataclass(slots=True)
class KillChain:
    """
    Phase C 输出：最终选定的 killchain（确保全链一致性）。
    """
    kc_uuid: str                        # KillChain 唯一标识符
    fsa_graph: FSAGraph                 # 关联的 FSA 图
    segments: List[SegmentSummary]      # 攻击阶段摘要列表
    selected_paths: List[CandidatePath] # LLM 选定的关键路径
    explanation: str                     # LLM 生成的攻击链解释
    confidence: float = 0.0             # LLM 评估的可信度 (0.0-1.0)
    trace: List[Dict[str, Any]] = field(default_factory=list)  # 分析过程追踪记录
\end{verbatim}

\subsubsection{SegmentSummary 结构}\label{killchain-segmentsummary}

\begin{verbatim}
@dataclass(slots=True)
class SegmentSummary:
    """
    单个战术阶段的摘要。
    """
    seg_idx: int                        # 段索引
    state: AttackState                  # 战术状态
    t_start: float                      # 段起始时间
    t_end: float                        # 段结束时间
    anchor_in_uid: str                  # 入口锚点 UID
    anchor_out_uid: str                 # 出口锚点 UID
    abnormal_edge_summaries: List[Dict] # 段内异常边摘要 (top 6)
\end{verbatim}

\subsubsection{CandidatePath 结构}\label{killchain-candidatepath}

\begin{verbatim}
@dataclass(slots=True)
class CandidatePath:
    """
    连接两个相邻段的候选路径。
    """
    path_id: str                        # 路径唯一标识
    src_anchor: str                     # 源锚点 UID
    dst_anchor: str                     # 目标锚点 UID
    t_min: float                        # 路径起始时间
    t_max: float                        # 路径终止时间
    edges: List[GraphEdge]              # 路径包含的边集合
    steps: List[Dict]                   # 精简的边摘要（供 LLM 使用）
    signature: str = ""                 # 路径签名（用于去重）
\end{verbatim}

\subsubsection{数据流示意}\label{killchain-data-flow}

\begin{verbatim}
Neo4j 图谱 (告警边 + Telemetry)
    │
    ├─→ Phase A: FSA 状态机
    │     ├─→ 识别战术阶段 (Segments)
    │     └─→ 选择段锚点 (anchors)
    │
    ├─→ Phase B: 候选路径枚举
    │     ├─→ 枚举段间路径 (CandidatePaths)
    │     └─→ 计算路径评分
    │
    ├─→ Phase C: LLM 路径选择
    │     ├─→ 输入裁剪 (PayloadReducer)
    │     ├─→ 启发式预筛 (HeuristicPreselector)
    │     ├─→ LLM 选择 (LLMChooser / MockChooser)
    │     └─→ 输出校验
    │
    └─→ Phase D: 持久化
          ├─→ 写入 custom.killchain.uuid (边)
          ├─→ 写入 analysis.task_id (节点)
          └─→ 写入任务结果 (OpenSearch)
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{KillChain 结果的输出形式}\label{killchain-output}

\subsubsection{持久化形式}\label{killchain-persistence}

KillChain 结果通过以下方式实现持久化：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Neo4j 边属性}：\texttt{custom.killchain.uuid}（遵循 ECS 合规字段规范）
\item
  \textbf{Neo4j 节点属性}：\texttt{analysis.task\_id}
\item
  \textbf{OpenSearch 任务文档}：\texttt{task.result.killchain}（可选，直接嵌入）
\end{enumerate}

实现绑定点：

\begin{itemize}
\tightlist
\item
  持久化逻辑：\texttt{backend/app/services/analyze/killchain.py:persist\_killchain\_to\_db()}
\end{itemize}

\subsubsection{前端查询方式}\label{killchain-frontend-query}

前端可通过以下方式获取 KillChain 结果：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{通过任务 ID 查询}：

  \begin{itemize}
  \tightlist
  \item
    接口：\texttt{GET\ /api/v1/analysis/tasks/\{task\_id\}}
  \item
    返回：\texttt{task.result.killchain\_uuid} 与 \texttt{task.result.killchain}
  \end{itemize}
\item
  \textbf{通过 kc\_uuid 直接查询}（可选）：

  \begin{itemize}
  \tightlist
  \item
    接口：\texttt{GET\ /api/v1/analysis/killchain/\{kc\_uuid\}}
  \item
    返回：完整的 KillChain 数据结构
  \end{itemize}
\end{enumerate}

\subsubsection{task.result 扩展字段}\label{killchain-task-result}

任务文档的 \texttt{task.result} 字段将扩展为：

\begin{verbatim}
{
  "task": {
    "result": {
      "ttp_similarity": {
        "attack_tactics": ["TA0001", "TA0006", ...],
        "attack_techniques": ["T1059", "T1055", ...],
        "similar_apts": [...]
      },
      "trace": {
        "updated_edges": 42,
        "path_edges": 8
      },
      "killchain_uuid": "abc-123-def",  // 新增：KillChain UUID
      "killchain": {                     // 新增（可选）：完整 KillChain 数据
        "kc_uuid": "abc-123-def",
        "confidence": 0.85,
        "segments": [
          {
            "seg_idx": 0,
            "state": "INITIAL_ACCESS",
            "t_start": 1234567890.0,
            "t_end": 1234567900.0,
            "anchor_in_uid": "Process:pid=1234",
            "anchor_out_uid": "Host:host.id=web-001",
            "abnormal_edge_count": 3
          },
          ...
        ],
        "selected_paths": [
          {
            "path_id": "p-abc123",
            "src_anchor": "Host:host.id=web-001",
            "dst_anchor": "Process:pid=5678",
            "hop_count": 3,
            "edge_ids": ["event-id-1", "event-id-2", "event-id-3"]
          },
          ...
        ],
        "explanation": "攻击者进程 p_c2 (pid:1234) 从外部 IP ..."
      }
    }
  }
}
\end{verbatim}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{LLM 解释文本生成规则}\label{killchain-explanation}

\subsubsection{解释文本要求}\label{killchain-explanation-requirements}

LLM 生成的 \texttt{explanation} 字段需满足以下要求：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{长度}：10-20 句中文
\item
  \textbf{结构}：关键节点描述应包含主谓宾结构
\item
  \textbf{内容}：至少涵盖以下要素：

  \begin{itemize}
  \tightlist
  \item
    初始入侵点识别
  \item
    内部网络中的横向移动路径
  \item
    权限提升路径分析
  \item
    数据泄露路径追踪（从存储到外传）
  \item
    基于攻击工具/脚本/配置文件指纹的攻击者归因
  \item
    C2 服务器 IP 地址分析
  \end{itemize}
\item
  \textbf{格式}：采用易懂的形式，并用括号标注实体

  \begin{itemize}
  \tightlist
  \item
    例如：\texttt{p\_c2\ (pid:1234)} 代表 c2 进程
  \item
    例如：\texttt{host\_web\ (host.id:host-001)} 代表 web 主机
  \item
    例如：\texttt{user\_admin\ (user.name:admin)} 代表管理员用户
  \end{itemize}
\end{enumerate}

\subsubsection{置信度评分}\label{killchain-confidence}

\texttt{confidence} 字段的评分规则如下：

\begin{itemize}
\tightlist
\item
  \textbf{取值范围}：0.0 - 1.0
\item
  \textbf{LLM 模式}：由 LLM 在输出中提供
\item
  \textbf{Fallback 模式}：固定为 0.5
\item
  \textbf{单段场景}：固定为 0.3
\end{itemize}

实现绑定点：

\begin{itemize}
\tightlist
\item
  LLM prompt：\texttt{backend/app/services/analyze/killchain\_llm.py:build\_choose\_prompt()}
\item
  置信度提取：\texttt{backend/app/services/analyze/killchain\_llm.py:validate\_choose\_result()}
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsection{与其他分析模块的关系}\label{killchain-integration}

\subsubsection{与 TTP 相似度匹配的关系}\label{killchain-ttp-similarity}

{\def\LTcaptype{none} % do not increment counter
\footnotesize
\begin{longtable}[]{@{}p{0.25\textwidth}p{0.12\textwidth}p{0.53\textwidth}@{}}
\toprule\noalign{}
维度 & KillChain & TTP 相似度匹配 \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{输入数据} & 图谱边 + 告警边 & Canonical Findings \\
\textbf{输出目标} & 攻击路径重建 & APT 组织归因 \\
\textbf{核心算法} & FSA + LLM & TF-IDF + 余弦相似度 \\
\textbf{结果形式} & 路径 + 解释文本 & Top-3 相似组织 \\
\textbf{展示方式} & 战术时间线 + 解释 & 相似度列表 \\
\end{longtable}
}

\subsubsection{与候选路径构造的关系}\label{killchain-candidate-paths}

KillChain 复用候选路径构造模块（Phase B），两者分工如下：

\begin{itemize}
\tightlist
\item
  \textbf{候选路径构造}：枚举所有可能的段间连接路径
\item
  \textbf{KillChain 选择}：借助 LLM 从候选路径中甄选最合理的路径
\end{itemize}

实现绑定点：

\begin{itemize}
\tightlist
\item
  候选路径构造：\texttt{backend/app/services/analyze/killchain.py:enumerate\_paths\_between\_anchors()}
\end{itemize}
