# 模块与数据流说明（面向组员快速上手）

这份文档的目标很直接：让没有参与前期调研的同学也能从头到尾理解——数据从哪来、怎么走、每一段用什么技术、最后怎么拼成一条“攻击链”并展示给老师看。

## 1. 先把概念钉死：系统里只有两类东西在流动

为了避免把“日志、告警、图谱、攻击链”混在一起，我们把所有数据归为两类：

1) **事实事件（Events / Telemetry）**  
只描述“发生了什么”：进程启动、用户登录、DNS 查询、网络连接、文件读写……不做善恶判断，像“监控录像”。

2) **告警/发现（Findings / Alerts）**  
描述“哪些事实值得怀疑”：命中某条规则、严重程度如何、对应哪个 ATT&CK 技术点、为什么怀疑，像“警报器响”。

另外还有一个很实用的工程细分：

- **Raw Findings（原始告警）**：所有来源的告警先都收下，便于追溯
- **Canonical Findings（规范告警）**：把同一件事的重复告警合并成一条，后续串链主要吃这一层

> 注意：本文中出现的“用户/账号（user）”指 **被监控主机/域环境中的系统账号**（用于重建登录会话、横向移动等），不是本系统的登录账号；本系统默认单用户使用，不做账号/权限管理。

## 2. 从采集到溯源：按时间顺序讲清楚整条链路

下面按“真实工程流水线”顺序，从端侧采集开始讲。

### 2.1 端侧采集：三路数据源分别负责什么

在靶场里你可以把每台主机/网络节点理解为“安装了传感器的取证现场”。传感器分三类，对应题目三路数据源：

- **主机日志（系统审计/门禁记录）**  
  目的：回答“谁在什么时候登录、创建了什么进程、权限是否变化”。  
  常用技术：Linux `auditd`、`auth.log`（SSH/sudo 等）。

- **主机行为（贴身跟拍视角）**  
  目的：回答“哪个进程访问了什么文件、什么时候发起了网络连接”。  
  常用技术：Falco（eBPF/内核事件生态，输出行为告警为主）。  
  课程项目建议：不要做全量 syscall 入库，优先用 Falco 的规则告警作为“主机行为”信号来源。

- **网络流量（路口监控与会话还原）**  
  目的：回答“谁连了谁、DNS 查了什么、HTTP/TLS 会话特征如何”。  
  常用技术：Zeek（高保真协议事实日志）、Suricata（规则告警）。

到这里为止，端侧会持续产生两类输出：

- 大量事实事件（telemetry）
- 少量告警（alerts，是否“端侧直接产告警”取决于你选择的传感器）

### 2.2 端侧轻量 Agent：翻译官 + 快递员

端侧通常会有一个轻量 Agent/采集管道，职责不是分析，而是：

- **时间一致**：NTP/时区统一；上报时统一时间格式
- **范式统一**：把不同格式映射到同一套字段（ECS 思想，统一标注 `ecs.version=9.2.0`）
- **可靠上报**：把数据稳定送到中心（失败重试/缓冲等）

常见可用技术：Fluent Bit、Vector（也可用你们自写脚本做最小映射）。

### 2.3 中心落库：OpenSearch 作为“案卷库”

中心侧的 **OpenSearch** 承担“案卷库”的角色：

- **事实事件索引（ecs-events-\*）**：只存 ECS 化后的事实事件
- **原始告警索引（raw-findings-\*）**：存所有来源的告警（端侧产的 + 中心扫出来的）
- **规范告警索引（canonical-findings-\*）**：对 raw 告警融合去重后的“唯一信号”（本项目默认生成，用于串链）

之所以要把事实和告警分开，是因为：

- 量级差异大（事实远多于告警）
- 生命周期不同（事实可短保留，告警/攻击链要更久便于复盘）
- 避免“告警又触发告警”的递归误扫

### 2.4 检测：告警从哪来（两条路）

很多同学会问“告警是客户端产还是中心产？”答案是：两种都可以。

- **Detect-first（端侧/传感器直接产告警）**  
  Suricata/Falco 这类工具自带规则引擎，会直接输出 alerts。

- **Store-first（中心侧在库里扫描产告警）**  
  中心侧使用 OpenSearch Security Analytics：从 `ecs-events-*` 读取事实事件，按 Sigma 规则持续检测，并把命中结果写回 `raw-findings-*`。

### 2.5 告警融合去重：把噪声变成置信度

Detect-first + Store-first 同时运行时，重复告警几乎不可避免。  
正确做法是：先把原始告警都收下，再生成一份“规范告警”（Canonical Findings）给后续串链用。

直觉理解：

- 同一件事被多个引擎同时看到，反而说明它更像真的（置信度加分）
- 但如果不融合去重，链条会被“重复节点”撑爆，图会变成毛线团

### 2.6 抽实体关系：写入 Neo4j 图谱

当你手里有了：

- 事实事件（OpenSearch）
- 规范告警（Canonical Findings）

就可以开始做“实体与关系抽取”：

- 从事实事件里抽实体：host/user/process/file/ip/domain/session…
- 从事实事件里抽关系：父子进程、登录会话、进程访问文件、进程发起连接、DNS 指向域名、域名解析到 IP…
- 把规范告警当作“标签/线索”：给某些节点/边标注 ATT&CK 技术点（例如 C2 外联）

实现上采用 Neo4j 作为实体关系图的权威存储，用于多跳路径推理与图展示。

### 2.7 关联与串链：把“线索”拼成“故事”

最后一步才是老师最关心的“溯源能力”：

- 以规范告警作为链条种子
- 按时间排成线、按实体连成图
- 加上时间窗约束（例如 5–20 分钟）控制因果可信度
- 在图上找路径：初始入侵 → 执行 →（可选：持久化/提权）→ 横向移动 → C2 → 外传

输出给老师看的不应该是一堆日志，而是：

- 一张时间线（每步一句话 + tactic/technique）
- 一张关系图（实体与边）
- 一套证据回放（每步能回指到原始事实事件）
- 一份 ATT&CK 覆盖可视化（Navigator layer）

## 3. 全流程技术名词（按流水线顺序串起来）

`auditd/auth.log（主机日志） + Falco（主机行为） + Zeek/Suricata（网络流量） → Fluent Bit/Vector（解析与 ECS 归一） → OpenSearch（事实事件入库） → Security Analytics + Sigma（库内检测） + 传感器 Alerts（源头检测） → Raw→Canonical（告警融合） → Neo4j 实体图 + 时间窗关联（攻击链重建） → 报告/可视化导出（Navigator layer 等）`
