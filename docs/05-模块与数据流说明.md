# 模块与数据流说明（面向组员快速上手）

这份文档的目标很直接：让没有参与前期调研的同学也能从头到尾理解——数据从哪来、怎么走、每一段用什么技术、最后怎么拼成一条"攻击链"并展示给老师看。

## 1. 核心概念

### 1.1 系统里只有两类数据在流动

为了避免把"日志、告警、图谱、攻击链"混在一起，我们把所有数据归为两类：

**1) 事实事件（Events / Telemetry）**

只描述"发生了什么"：进程启动、用户登录、DNS 查询、网络连接、文件读写……不做善恶判断，像"监控录像"。

**2) 告警/发现（Findings / Alerts）**

描述"哪些事实值得怀疑"：命中某条规则、严重程度如何、对应哪个 ATT&CK 技术点、为什么怀疑，像"警报器响"。

### 1.2 告警的工程细分

- **Raw Findings（原始告警）**：所有来源的告警先都收下，便于追溯
- **Canonical Findings（规范告警）**：把同一件事的重复告警合并成一条，后续串链主要吃这一层

### 1.3 重要说明

> 注意：本文中出现的"用户/账号（user）"指 **被监控主机/域环境中的系统账号**（用于重建登录会话、横向移动等），不是本系统的登录账号；本系统默认单用户使用，不做账号/权限管理。

---

## 2. 六大核心模块

### 2.1 模块 1：数据采集层

**组件**：Filebeat(+Sigma) / Falco / Suricata

**输入**：主机行为、网络流量

**输出**：各自格式的 JSON 事件 + 告警

**职责**：

- **Filebeat（主机系统日志）**：回答"谁在什么时候登录、创建了什么进程、权限是否变化"
- **Falco（主机行为）**：回答"哪个进程访问了什么文件、什么时候发起了网络连接"
- **Suricata（网络流量）**：回答"谁连了谁、DNS 查了什么、HTTP/TLS 会话特征如何"

**技术细节**：

- 本项目主机系统日志采集使用 Filebeat；异常检测使用 Sigma 规则（可端侧或中心侧）
- 本项目主机行为监控只用 Falco（输出行为告警为主，不做全量 syscall 入库）
- 本项目网络流量只用 Suricata（EVE JSON 同时产出 flow/dns/http… + alert）

---

### 2.2 模块 2：客户端后端

**组件**：Go 服务

**输入**：3 路采集器的 JSON 输出

**输出**：ECS 格式事件 + 告警（通过 `/pull` 接口被拉取）

**职责**：

- **时间一致**：NTP/时区统一；输出统一时间格式
- **范式统一**：把不同格式映射到同一套字段（ECS 子集 + `custom.*`；见 `docs/06A-ECS字段规范.md`）
- **本地缓冲**：中心机拉取变慢时，客户端能顶住（本项目采用 SQLite）
- **启动注册**：客户端启动后主动向中心机注册（告诉中心机"我是谁、我在哪、我有什么能力"）
- **提供拉取接口**：注册成功后，中心机通过轮询客户端后端接口拉取数据

接口规范见：`docs/06C-客户端中心机接口规范.md`

---

### 2.3 模块 3：中心机后端

**组件**：Python FastAPI

**输入**：客户端注册请求、拉取响应

**输出**：写入 OpenSearch 的数据、RESTful API 响应

**职责**：

- **注册表（Registry）**：接收客户端注册，维护客户端清单（`client_id/listen_url/capabilities/last_seen/cursor` 等）
- **轮询器（Poller）**：按 interval 轮询客户端，拉取新事件/告警
- **入库与索引**：写入 OpenSearch（Telemetry/Findings/Chains…）并驱动后续检测/关联
- **API 服务**：提供 RESTful API 供前端调用

---

### 2.4 模块 4：存储与检测层

**组件**：OpenSearch + Security Analytics

**输入**：ECS 事件 + 告警

**输出**：3 个索引的数据

**职责**：

- **事实事件索引（ecs-events-\*）**：只存 ECS 化后的事实事件
- **原始告警索引（raw-findings-\*）**：存所有来源的告警（端侧产的 + 中心扫出来的）
- **规范告警索引（canonical-findings-\*）**：对 raw 告警融合去重后的"唯一信号"（本项目默认生成，用于串链）
- **Store-first 检测**：OpenSearch Security Analytics 读取 `ecs-events-*`，按 Sigma 规则持续检测，并把命中结果写回 `raw-findings-*`

**为什么要把事实和告警分开？**

- 量级差异大（事实远多于告警）
- 生命周期不同（事实可短保留，告警/攻击链要更久便于复盘）
- 避免"告警又触发告警"的递归误扫

---

### 2.5 模块 5：关联分析层

**组件**：Python 算法模块（驱动 Neo4j GDS，消费离线 MITRE ATT&CK Enterprise CTI｜STIX 2.1｜attack-stix-data）

**输入**：OpenSearch 中的 Telemetry + Findings

**输出**：

- 攻击链数据（写入 `attack-chains-*` 索引）
- 实体关系数据（写入 Neo4j）
- ATT&CK 映射结果

**职责**：

- **告警融合**：把多源重复告警合并成 Canonical Findings
- **时间窗关联**：在 Δt 时间窗口内聚合相关事件/告警
- **实体关系抽取**：
  - 从事实事件里抽实体：host/user/process/file/ip/domain（session 为派生概念）
  - 从事实事件里抽关系：父子进程、登录会话、进程访问文件、进程发起连接、DNS 指向域名、域名解析到 IP
  - 把规范告警当作"标签/线索"：给某些节点/边标注 ATT&CK 技术点（例如 C2 外联）
- **攻击链重建**：
  - 以规范告警作为链条种子
  - 按时间排成线、按实体连成图
  - 加上时间窗约束（例如 5–20 分钟）控制因果可信度
  - 在图上找路径：使用 **Neo4j GDS 加权最短路**输出关键路径（初始入侵 → 执行 → 横向移动 → C2 → 外传；阶段由证据决定）
- **APT 相似度匹配**：基于离线 MITRE ATT&CK Enterprise CTI（Intrusion Set ↔ Technique）+ TF-IDF 向量 + 余弦相似度，在中心机分析模块中输出 Top-3 候选组织与解释性 techniques

---

### 2.6 模块 6：展示层

**组件**：Next.js + React 前端

**输入**：攻击链 + 实体关系数据（通过 API 从后端获取）

**输出**：可视化界面 + 报告

**职责**：

- **前端页面**：从中心机后端 API 获取数据并展示
- **Neo4j**：作为实体关系图的权威存储，用于多跳路径推理与图展示（由后端访问）
- **UI 展示**：
  - 时间线视图：按时间展示攻击各阶段
  - 关系图可视化：交互式图谱（节点可点击查看证据）
  - 攻击链报告：阶段摘要 + 关键路径 + ATT&CK 标注
- **报告导出**：
  - ATT&CK Navigator layer
  - 证据包：关键证据 event_id/raw_ref 列表 + 截图说明

---

## 3. 数据流完整路径（6 步走）

```
Step 1️⃣ 采集层
   Filebeat(+Sigma)/Falco/Suricata
   → 各自格式的 JSON 事件 + 告警
   ⬇️

Step 2️⃣ 客户端后端
   → ECS 归一化（统一字段格式）
   → SQLite 缓冲（本地存储）
   → 启动注册
   → 提供 /health + /pull 接口
   ⬇️

Step 3️⃣ 中心机后端
   → 接收注册，维护注册表
   → 轮询拉取客户端数据
   → 写入 OpenSearch（3个索引）
   ⬇️

Step 4️⃣ 分析层
   → 告警融合：raw → canonical
   → 时间窗关联：聚合相关事件
   → 实体关系抽取：提取节点和边
   → 攻击链重建：识别攻击路径
   → APT 相似度匹配：输出候选组织
   ⬇️

Step 5️⃣ 图谱层
   → Neo4j 存储实体关系图
   → 支持多跳查询和路径推理
   ⬇️

Step 6️⃣ 展示层
   → Next.js UI 从 OpenSearch + Neo4j 读取数据
   → 展示时间线 / 关系图 / 攻击链
   → 导出报告和证据包
```

### 3.1 Step 1️⃣ 采集层：三路数据从哪来

在靶场里你可以把每台被监控主机理解为"安装了传感器的取证现场"。本项目每台客户机包含 3 个采集器：

**主机日志（系统审计/门禁记录）**

- 目的：回答"谁在什么时候登录、创建了什么进程、权限是否变化"
- 技术选择：Filebeat（本项目主机系统日志采集使用 Filebeat；异常检测使用 Sigma 规则）

**主机行为（贴身跟拍视角）**

- 目的：回答"哪个进程访问了什么文件、什么时候发起了网络连接"
- 技术选择：Falco（本项目主机行为监控只用 Falco，输出行为告警为主）
- 课程项目建议：不要做全量 syscall 入库，优先用 Falco 的规则告警作为"主机行为"信号来源

**网络流量（路口监控与会话还原）**

- 目的：回答"谁连了谁、DNS 查了什么、HTTP/TLS 会话特征如何"
- 技术选择：Suricata（本项目网络流量只用 Suricata；EVE JSON 同时产出 flow/dns/http… + alert）

到这里为止，客户机端会持续产生两类输出：

- 大量事实事件（telemetry）
- 少量告警（alerts）

---

### 3.2 Step 2️⃣ 客户端后端：归一化 + 缓冲 + 注册

客户端后端的职责不是做深度分析，而是把数据可靠送到中心机，并保证后续能"串链"：

**时间一致**：NTP/时区统一；输出统一时间格式

**范式统一**：把不同格式映射到同一套字段（ECS 子集 + `custom.*`；见 `docs/06A-ECS字段规范.md`）

**本地缓冲**：中心机拉取变慢时，客户端能顶住（本项目采用 SQLite）

**启动注册**：客户端启动后主动向中心机注册（告诉中心机"我是谁、我在哪、我有什么能力"）

**提供拉取接口**：注册成功后，中心机通过轮询客户端后端接口拉取数据

接口规范见：`docs/06C-客户端中心机接口规范.md`

---

### 3.3 Step 3️⃣ 中心机后端：注册表 + 轮询 + 入库

中心机采用 **前后端分离架构**：

**后端（Python FastAPI）**：
- 维护注册表与轮询状态
- 按定时轮询客户端数据
- 写入 OpenSearch/Neo4j
- 驱动后续检测/关联
- 提供 RESTful API 供前端调用

**前端（Next.js + React）**：
- 通过 API 调用后端服务
- 展示时间线、告警、关系图、攻击链
- 导出报告和证据包

**OpenSearch 作为"案卷库"**：

- **事实事件索引**：只存 ECS 化后的事实事件
- **原始告警索引**：存所有来源的告警（端侧产的 + 中心扫出来的）
- **规范告警索引**：对 raw 告警融合去重后的"唯一信号"（本项目默认生成，用于串链）

---

### 3.4 Step 4️⃣ 分析层：检测 + 融合 + 关联

**4.4.1 两条检测路径**

很多同学会问"告警是客户端产还是中心产？"答案是：两种都可以。

**Detect-first（端侧/传感器直接产告警）**

Filebeat+Sigma/Falco/Suricata 都可能直接产出 alerts（本项目先全收，统一为 Raw Findings）。

**Store-first（中心侧在库里扫描产告警）**

中心侧使用 OpenSearch Security Analytics：从 `ecs-events-*` 读取事实事件，按 Sigma 规则持续检测，并把命中结果写回 `raw-findings-*`。

**4.4.2 告警融合去重**

Detect-first + Store-first 同时运行时，重复告警几乎不可避免。

正确做法是：先把原始告警都收下，再生成一份"规范告警"（Canonical Findings）给后续串链用。

直觉理解：

- 同一件事被多个引擎同时看到，反而说明它更像真的（置信度加分）
- 但如果不融合去重，链条会被"重复节点"撑爆，图会变成毛线团

**4.4.3 实体关系抽取**

当你手里有了：

- 事实事件（OpenSearch）
- 规范告警（Canonical Findings）

就可以开始做"实体与关系抽取"：

- 从事实事件里抽实体：host/user/process/file/ip/domain（session 为派生概念）…
- 从事实事件里抽关系：父子进程、登录会话、进程访问文件、进程发起连接、DNS 指向域名、域名解析到 IP…
- 把规范告警当作"标签/线索"：给某些节点/边标注 ATT&CK 技术点（例如 C2 外联）

---

### 3.5 Step 5️⃣ 图谱层：Neo4j 实体关系图

实现上采用 Neo4j 作为实体关系图的权威存储，用于多跳路径推理与图展示。

**图模型的节点类型（Node Types）**：

- `host`、`user`、`process`、`file`、`ip`、`domain`（`session` 为派生概念，不单独作为节点长期落地）

**边类型（Edge Types）**：

- `LOGON`：用户登录主机（`User → Host`）
- `RUNS_ON`：进程归属主机（`Process → Host`）
- `SPAWN`：父进程创建子进程（`Process → Process`）
- `FILE_ACCESS`：文件访问（优先 `Process → File`，必要时可降级 `Host → File`）
- `NET_CONNECT`：网络连接（优先 `Process → IP`，缺进程信息时降级 `Host → IP`）
- `DNS_QUERY`：DNS 查询（`Host/Process → Domain`）
- `RESOLVES_TO`：域名解析到 IP（`Domain → IP`，可选边）
- `HAS_IP`：主机拥有本机 IP（`Host → IP`，可选边）

每条边必须携带 `custom.evidence.event_ids`，能回溯到 Telemetry/Findings。

> 说明：node/edge 的权威规格与抽取口径以 `docs/09-实体图谱节点与关系规范v2.md` 为准；本节仅描述数据流分层与落库位置。

---

### 3.6 Step 6️⃣ 展示层：攻击链 + 报告导出

最后一步才是老师最关心的"溯源能力"：

**前端展示（Next.js + React）**：

- 通过 API 从后端获取数据
- 展示时间线、关系图、攻击链
- 导出报告和证据包

**攻击链重建（由后端算法完成）**：

- 以规范告警作为链条种子
- 按时间排成线、按实体连成图
- 加上时间窗约束（例如 5–20 分钟）控制因果可信度
- 在图上找路径：使用 **Neo4j GDS 加权最短路**输出关键路径（初始入侵 → 执行 → 横向移动 → C2 → 外传；阶段由证据决定）

**输出物**：

输出给老师看的不应该是一堆日志，而是：

- **一张时间线**：每步一句话 + tactic/technique
- **一张关系图**：实体与边
- **一套证据回放**：每步能回指到原始事实事件
- **一份 ATT&CK 覆盖可视化**：Navigator layer

---

## 4. 关键技术点

### 4.1 两条检测路径

**Detect-first（源头产 Findings）**

- 典型来源：Suricata、Falco、Filebeat+Sigma
- 特点：快速见效、开发友好；但需要后续统一字段，跨主机/跨源关联仍要自研
- 输入：本机/本链路遥测 + 本地规则
- 输出：告警事件（Alert/Finding），含规则名、严重度、关键实体

**Store-first（入库后扫描产 Findings）**

- 典型来源：Sigma 规则库 + OpenSearch Security Analytics
- 特点：字段统一、跨源更强；但前置"解析/映射"质量要求高
- 输入：ECS Telemetry 索引 + 规则（Sigma/自定义）
- 输出：Findings/Alerts（统一结构）

---

### 4.2 告警融合去重

**三层数据（逻辑分层）**：

- **Telemetry（事实层）**：ECS 规范化事件，作为证据原文与上下文（量最大）
- **Raw Findings（原始告警层）**：所有来源的告警先全部收下，用于回溯与审计（量中等）
- **Canonical Findings（规范告警层）**：对 Raw Findings 去重/合并后的"唯一信号"，后续串链只吃这一层（量最小）

**核心收益**：

1. 避免"同一件事被喊 5 次"导致链条虚假拉长
2. 多引擎对同一行为的共识可转化为更高置信度
3. 关联图可视化更干净，不会变成"毛线团"

**融合策略（MVP 可落地）**：

在时间窗 Δt 内，将满足下列条件的 Raw Finding 合并为一条 Canonical Finding：

- 指纹建议由以下元素组成：`technique_id + host + (process_entity_id | dst_ip/domain | file_hash) + time_bucket`
- 其中 `time_bucket = floor(@timestamp / Δt)`，Δt 可取 1–5 分钟（实验规模小建议偏小）

合并时：

- `custom.finding.providers`：来源引擎追加（suricata/falco/opensearch-security-analytics…）
- `custom.evidence.event_ids`：证据引用合并去重
- `event.severity`：取 max 或加权
- `custom.confidence`：可按"来源数量/一致性"上调

---

### 4.3 攻击链重建策略

**关联键（Join Keys）**：

优先用以下键连边（从强到弱）：

1. `process.entity_id` / PID-PPID 链
2. `user + logon_id/session_id`
3. `destination.ip/domain`（外联/C2/外传）
4. 时间窗口 Δt 约束（例如 5–20 分钟）

**攻击链抽取**：

> 本项目以 **Canonical Findings** 作为攻击链的"种子/节点"。

1. 将每个 technique 映射到 tactic（ATT&CK 自带映射关系）
2. 规定阶段顺序（示例）：
   `Initial Access → Execution → Persistence → Privilege Escalation → Lateral Movement → Command and Control → Exfiltration`
3. 从"初始入侵候选点"（外联入口/可疑登录/漏洞利用告警）出发，在图上做路径搜索：
   - 使用 **Neo4j GDS 加权最短路**完成路径搜索
   - 图投影按时间窗 Δt 过滤，并限定关系类型（进程链 / 登录会话 / 网络外联 / DNS 解析 / 文件访问）
   - 边权重按关联强度生成：强关联权重更低，弱关联权重更高
4. 输出：
   - 时间线（technique 序列）
   - 路径图（节点/边 + 每步 technique）
   - 阶段摘要（每个 tactic 的关键证据与持续时间）

**APT/TTP 相似性匹配**：

严格归因较难，课程项目更合理的做法是基于 TTP 做相似性匹配：

- 取指定范围内的 **Canonical Findings**（`event.dataset="finding.canonical"`）抽取 technique 集合 `S` 并生成向量 `V_attack`
- 取离线 MITRE ATT&CK Enterprise CTI（STIX 2.1｜attack-stix-data｜默认路径：`backend/app/services/ttp_similarity/cti/enterprise-attack.json`，可用 `ATTACK_CTI_PATH` 覆盖）数据包中的 Intrusion Set → technique 集合，生成每个组织的向量 `V_i`（数据文件可用 `backend/scripts/fetch_mitre_attack_cti.sh` 获取/更新）。
- 对 technique 做 IDF 加权（稀有 technique 权重更高），得到 `V_attack_tfidf` 与 `V_i_tfidf`
- 相似度使用余弦相似度：`cosine(V_attack_tfidf, V_i_tfidf)`
- 相似度计算在中心机分析模块中完成（Top-3 排序输出）

输出字段（固定口径）：

- Top-3 候选组织 + 相似度分数
- 贡献度最高的 5 个 techniques（作为解释）：按 `V_attack(t) * V_i(t) * idf(t)` 排序取 Top

> 输出措辞统一使用"相似度最高的候选"，避免宣称"确定归因"。

**输入范围（固定口径）**：

- 以 `host.id` + `[start_ts, end_ts]` 时间窗定义“本次攻击实例”的分析范围；
- 仅消费 OpenSearch `canonical-findings-*` 中落入该范围的文档。

**Technique 清洗规则（固定口径）**：

- 仅使用 `threat.technique.id` 字段；
- 过滤占位/无效标注：`T0000`、`Unknown`、空值、以及不符合 `Txxxx` / `Txxxx.xxx` 格式的值。
- 若为子技术（`Txxxx.xxx`），同时计入其父技术（`Txxxx`）。

**TF 定义（固定口径）**：

- 二值 TF：若 technique `t` 在范围内出现过，则 `tf(t)=1`；否则 `tf(t)=0`。

---

## 5. 全流程技术栈速查

```
Filebeat(+Sigma)/Falco/Suricata（采集）
  → 客户端后端（Go：ECS 归一化 + SQLite 缓冲 + 注册 + /health + /pull）
  → 中心机后端（FastAPI：注册表 + 轮询拉取 + API）
  → OpenSearch（ecs-events-* / raw-findings-* / canonical-findings-*）
  → Security Analytics + Sigma（Store-first 检测）
  → 告警融合（Raw → Canonical）
  → Python 关联算法（实体抽取 + GDS 加权最短路串链 + TTP 相似度）
  → Neo4j + GDS（实体关系图 + 图算法）
  → 中心机前端（Next.js + React：时间线 / 关系图 / 攻击链 / 报告导出 / Navigator layer）
```

**技术栈清单**：

| 步骤       | 技术                       | 产出                        |
| ---------- | -------------------------- | --------------------------- |
| 采集       | Filebeat(+Sigma) / Falco / Suricata | 原始日志 + 告警             |
| 客户端后端 | Go + SQLite                | ECS 事件 + 告警             |
| 中心机后端 | Python FastAPI + uv       | API + 注册表 + 轮询器       |
| 存储       | OpenSearch                 | 3 个索引                    |
| 检测       | Security Analytics + Sigma | Raw Findings                |
| 分析       | Python + Neo4j GDS + 离线 ATT&CK Enterprise CTI(STIX 2.1) | Canonical Findings + 攻击链 + 相似 APT 候选 |
| 图谱       | Neo4j + GDS                | 实体关系图 + 图算法结果     |
| 展示       | Next.js + React            | UI + 报告                   |
