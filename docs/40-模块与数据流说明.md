# 模块与数据流说明（快速上手）

本文只讲“故事线”与“输入输出”，用于新同学快速理解系统怎么跑起来、数据怎么走。字段细节与接口细节分别引用 5x 文档与 31/32/33。

## 1. 数据分层与术语（最小集）

系统中只有五类数据对象：

1. **Telemetry**：事实事件（ECS，`event.kind="event"`），落 OpenSearch `ecs-events-*`。
2. **Raw Finding**：原始告警（ECS，`event.kind="alert"` 且非 canonical），落 OpenSearch `raw-findings-*`。
3. **Canonical Finding**：规范告警（ECS，`event.kind="alert"` 且 `event.dataset="finding.canonical"`），落 OpenSearch `canonical-findings-*`。
4. **Entity Graph**：实体关系图（Neo4j），输入为 Telemetry + Canonical Finding。
5. **Trace Task**：溯源任务（OpenSearch 任务索引 + Neo4j 边属性写回）。

## 2. 端到端数据流（中心机单定时器流水线）

### 2.1 客户机侧（每台主机）

1) 传感器采集并输出：Filebeat / Falco / Suricata。  
2) 客户机侧把采集结果转换为 ECS 文档（字段口径见 `51-ECS字段规范.md`）。  
3) ECS 文档写入本机 RabbitMQ 队列作为缓冲。  
4) 客户机对外提供拉取接口（从队列取出并返回），供中心机轮询（接口口径见 `54-客户机-中心机接口规范.md`）。

### 2.2 中心机侧（每次 tick，严格顺序）

中心机定时器每次触发按顺序执行：

1) **拉取**：从所有已注册客户机拉取新数据。  
2) **入库**：写入 OpenSearch（Telemetry/Raw Findings 路由，三时间字段处理与幂等去重）。  
3) **检测与融合**：Store-first 检测产出 Raw Findings，并融合生成 Canonical Findings 写回 OpenSearch。  
4) **入图**：以 Canonical Findings 为主、补充必要 Telemetry，转换为图并写入 Neo4j。  

上述四步由同一个定时器驱动，形成“一条龙”流水线，系统规格见 `30-系统规格说明书.md`。

> 实现提示（与当前代码对齐）：
>
> - 后端默认只在 tick 内执行 Step 1/2（轮询客户机 + 入库规范化）；
> - Step 3 可通过环境变量 `CENTER_RUN_ANALYSIS_EACH_TICK=1` 打开；
> - Step 4 当前通常以离线/手动方式触发（例如调试脚本或后续扩展为定时执行）。

## 3. 前端可视化数据流

1) 老师打开前端页面。  
2) 前端请求后端：
   - 查事件/告警：后端查询 OpenSearch；
   - 查图：后端查询 Neo4j。  
3) 前端渲染：
   - 事件时间线（来自 OpenSearch）；
   - 图谱（来自 Neo4j 返回的 nodes/edges）。  

## 4. 溯源任务数据流

1) 老师在图上选定一个节点（node uid）。  
2) 前端请求后端创建溯源任务，后端立即返回 `task_id`。  
3) Analysis 模块异步执行：读取 Neo4j 子图 → 算法分析 → 生成关键路径与解释。  
4) Analysis 模块把结果写回 Neo4j 边属性（字段口径见 `32/33`）。  
5) 前端轮询任务状态，任务完成后再次请求图查询接口，读取边属性并展示溯源结果。  
6) 前端导出报告：包含告警、图谱与溯源结果。
