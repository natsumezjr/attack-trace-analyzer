# 客户机规格说明书

## 0. 文档定位与引用关系

本文件定义**客户机侧**的实现规格与职责边界。

客户机侧负责：
- 数据采集（Falco/Filebeat/Suricata）
- ECS 转换（字段归一化）
- 本地缓冲（RabbitMQ 队列）
- 对外接口（Go Backend 暴露 3 个 GET endpoint）

本文件不重复以下文档的细节：
- **接口格式**：见 `54-客户机-中心机接口规范.md`
- **ECS 字段口径**：见 `51-ECS字段规范.md`
- **环境变量**：见 `53-环境变量规范.md`
- **中心机流水线**：见 `30-系统规格说明书.md`

---

## 1. 客户机架构

### 1.1 组件清单

客户机由以下容器组成：

| 容器名称 | 镜像来源 | 职责 |
|---------|---------|------|
| `rabbitmq` | `rabbitmq:management` | 消息队列（缓冲区） |
| `falco` | `falcosecurity/falco:0.42.1` | 系统调用监控 |
| `falco-ecs` | 自建镜像 | Falco 事件转 ECS |
| `filebeat` | 自建镜像 | 主机日志采集 |
| `suricata` | 自建镜像 | 网络 IDS |
| `suricata-exporter` | 自建镜像 | Suricata EVE 转 ECS |
| `backend` | 自建镜像 | Go HTTP 服务器 |

### 1.2 容器依赖关系

```
rabbitmq (健康检查) ←── 所有容器依赖
├── falco (启动后) ←── falco-ecs 依赖
├── filebeat (独立)
├── suricata (启动后) ←── suricata-exporter 依赖
└── backend (等待所有传感器启动)
```

---

## 2. 传感器组件

### 2.1 Falco 传感器 + ECS 转换器

**容器：** `falco` + `falco-ecs`

#### 2.1.1 Falco 传感器配置

```yaml
image: falcosecurity/falco:0.42.1
privileged: true
pid: host
volumes:
  - /var/run/docker.sock:/host/var/run/docker.sock
  - /dev:/host/dev
  - /proc:/host/proc:ro
  - /boot:/host/boot:ro
command:
  - falco
  - -o json_output=true
  - -o file_output.enabled=true
  - -o file_output.filename=/data/falco.jsonl
```

**输出格式：** Falco JSONL（每行一个 JSON 对象）

#### 2.1.2 ECS 转换器 (`falco-ecs`)

**职责：**
- 读取 `/data/falco.jsonl`（tail -f）
- 将 Falco 事件转换为 ECS 格式
- 发布到 RabbitMQ 队列 `data.falco`

**环境变量：**
```bash
RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672/
RABBITMQ_QUEUE=data.falco
```

**输出 ECS 文档示例：**
```json
{
  "ecs": {"version": "9.2.0"},
  "event": {
    "id": "evt-3a7b8c9d0e1f2a4b",
    "kind": "event",
    "dataset": "hostbehavior.syscall",
    "category": ["process"],
    "action": "exec"
  },
  "host": {"id": "h-1111111111111111", "name": "victim-01"},
  "process": {
    "pid": 1234,
    "executable": "/bin/bash",
    "command_line": "bash -c 'echo test'"
  },
  "message": "Executed bash command"
}
```

**转换规则：**
- `event.dataset` 固定为 `hostbehavior.syscall`
- 必须填充 `host.id`、`host.name`（来自环境变量或推断）
- 必须填充 `process.pid`、`process.executable`
- 必须生成 `event.id`（规则见 `51-ECS字段规范.md` 第 0.5.2 节）

---

### 2.2 Filebeat 传感器 + 检测器

**容器：** `filebeat`

#### 2.2.1 Filebeat 配置

```yaml
volumes:
  - /var/log:/var/log/host:ro
environment:
  - TZ=Asia/Shanghai
  - RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672/
  - RABBITMQ_QUEUE=data.filebeat
```

**职责：**
- 采集主机日志（`/var/log/syslog`, `/var/log/auth.log` 等）
- 转换为 ECS 格式
- 检测登录事件（通过日志解析）
- 发布到 RabbitMQ 队列 `data.filebeat`

**输出 ECS 文档示例（登录事件）：**
```json
{
  "ecs": {"version": "9.2.0"},
  "event": {
    "id": "evt-b4c8d0e1f2a4b5c9",
    "kind": "event",
    "dataset": "hostlog.auth",
    "category": ["authentication"],
    "action": "user_login",
    "outcome": "success"
  },
  "host": {"id": "h-1111111111111111", "name": "victim-01"},
  "user": {"name": "root"},
  "source": {"ip": "10.0.0.5"},
  "message": "User root logged in from 10.0.0.5"
}
```

**转换规则：**
- `event.dataset` 可选值：`hostlog.auth`、`hostlog.process`、`hostlog.file_registry`
- 必须填充 `user.name`、`source.ip`
- 必须生成 `event.id`

---

### 2.3 Suricata 传感器 + EVE 导出器

**容器：** `suricata` + `suricata-exporter`

#### 2.3.1 Suricata 引擎配置

```yaml
network_mode: host
cap_add:
  - NET_ADMIN
  - NET_RAW
environment:
  - SURICATA_MODE=live
  - SURICATA_INTERFACE=auto
  - SURICATA_HOME_NET=auto
```

**职责：**
- 监听网络流量（live 模式）
- 输出 EVE 日志（JSON 格式）

**EVE 日志示例（DNS 事件）：**
```json
{
  "timestamp": "2026-01-14T12:00:00.000+08:00",
  "event_type": "dns",
  "src_ip": "10.0.0.10",
  "dest_ip": "8.8.8.8",
  "dns": {
    "query": "example.com",
    "type": "A"
  }
}
```

#### 2.3.2 EVE 导出器 (`suricata-exporter`)

**职责：**
- 读取 EVE 日志文件
- 转换为 ECS 格式
- 发布到 RabbitMQ 队列 `data.suricata`

**环境变量：**
```bash
HOST_ID=sensor-01
HOST_NAME=suricata-sensor
RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672/
RABBITMQ_QUEUE=data.suricata
```

**输出 ECS 文档示例：**
```json
{
  "ecs": {"version": "9.2.0"},
  "event": {
    "id": "evt-c5d9e1f2a4b5c6d0",
    "kind": "event",
    "dataset": "netflow.dns",
    "category": ["network"],
    "action": "dns_query"
  },
  "host": {"id": "h-1111111111111111", "name": "victim-01"},
  "source": {"ip": "10.0.0.10"},
  "destination": {"ip": "8.8.8.8"},
  "dns": {"question": {"name": "example.com"}},
  "network": {"transport": "udp", "protocol": "dns"}
}
```

**转换规则：**
- `event.dataset` 可选值：`netflow.dns`、`netflow.http`、`netflow.tls`、`netflow.flow`
- 必须填充 `source.ip`、`destination.ip`
- 必须生成 `event.id`

---

## 3. Go Backend（对外接口）

### 3.1 职责

Go Backend (`backend` 容器) 负责：
- 从 RabbitMQ 队列消费消息
- 暴露 3 个 HTTP GET 接口（`/falco`、`/filebeat`、`/suricata`）
- 简化实现：**无鉴权、无游标、无参数**

### 3.2 技术栈

- **语言**：Go
- **框架**：Gin
- **端口**：8888
- **依赖**：RabbitMQ AMQP 091-go 客户端

### 3.3 接口定义

#### 3.3.1 `GET /falco`

**请求：** 无参数（空 POST）

**响应：**
```json
{
  "total": 120,
  "data": [
    {"ecs": {"version": "9.2.0"}, "event": {"id": "evt-..."}},
    // ... more events
  ]
}
```

#### 3.3.2 `GET /filebeat`

同上格式，队列名：`data.filebeat`

#### 3.3.3 `GET /suricata`

同上格式，队列名：`data.suricata`

### 3.4 RabbitMQ 消费逻辑

**文件：** `client/backend/queue/client.go`

```go
func (c *Client) FetchAll(queueName string) ([]json.RawMessage, error) {
    // 1. 获取 RabbitMQ Channel
    ch, _ := c.conn.Channel()
    defer ch.Close()

    // 2. 声明队列（durable=True）
    _, _ = ch.QueueDeclare(queueName, true, false, false, false, nil)

    // 3. 持续消费直到队列为空
    var out []json.RawMessage
    for {
        msg, ok, _ := ch.Get(queueName, false)
        if !ok {
            break  // 队列为空
        }

        out = append(out, msg.Body)
        msg.Ack(false)  // 消息被确认，从队列删除
    }

    return out, nil
}
```

**关键点：**
- **一次性拉取所有**：`FetchAll()` 消费队列中所有可用消息
- **ACK 保证不重复**：消息被消费后从队列删除，下次拉取不会再次出现
- **无需 cursor**：RabbitMQ 队列天然保证增量（比游标机制更简单）
- **重连机制**：连接断开时自动重连

---

## 4. ECS 转换规则（通用）

### 4.1 三时间字段处理

所有传感器必须保证：

| 字段 | 语义 | 规则 |
|------|------|------|
| `@timestamp` | 事件发生时间 | 从原始日志提取；缺失时使用 `event.created` |
| `event.created` | 传感器观察到的时间 | 传感器当前时间 |
| `event.ingested` | 入库时间 | **由中心机覆盖**，客户机可不填或填任意值 |

### 4.2 event.id 生成规则

**规则：** 见 `51-ECS字段规范.md` 第 0.5.2 节

**当前实现：**
```python
# 当上游事件已有 event.id 时：直接透传
# 当上游事件缺失 event.id 时：
event.id = "evt-" + sha1(raw_payload_bytes)[:16]
```

**稳定性保证：**
- 同一条消息重复处理 → 相同的 `event.id`
- 中心机可基于 `event.id` 幂等去重

### 4.3 dataset 命名体系

| 传感器 | event.dataset 取值 |
|--------|-------------------|
| Falco | `hostbehavior.syscall` |
| Filebeat | `hostlog.auth`, `hostlog.process`, `hostlog.file_registry` |
| Suricata | `netflow.dns`, `netflow.http`, `netflow.tls`, `netflow.flow` |

---

## 5. 容器编排（docker-compose.yml）

### 5.1 服务启动顺序

```
1. rabbitmq (健康检查通过后)
   ↓
2. falco + filebeat + suricata (启动后)
   ↓
3. falco-ecs + suricata-exporter (依赖 2)
   ↓
4. backend (等待所有传感器启动)
```

**健康检查：**
```yaml
healthcheck:
  test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
  interval: 5s
  timeout: 5s
  retries: 12
```

### 5.2 环境变量配置

**关键变量：**
```bash
# RabbitMQ 连接
RABBITMQ_URL=amqp://guest:guest@rabbitmq:5672/

# 队列名称
FALCO_QUEUE=data.falco
FILEBEAT_QUEUE=data.filebeat
SURICATA_QUEUE=data.suricata

# 主机标识（Suricata 导出器使用）
HOST_ID=sensor-01
HOST_NAME=suricata-sensor
```

**完整环境变量列表：** 见 `53-环境变量规范.md` 第 2.7 节

### 5.3 数据卷

```yaml
volumes:
  - ./data:/data  # 共享数据目录（Falco 输出、Suricata EVE 等）
  - /var/log:/var/log/host:ro  # 主机日志（只读）
```

---

## 6. 部署与运维

### 6.1 启动客户机

```bash
cd client/
docker-compose up -d
```

**预期输出：**
```
Creating network "client_default"
Creating container "rabbitmq"
Creating container "falco"
Creating container "falco-ecs"
Creating container "filebeat"
Creating container "suricata"
Creating container "suricata-exporter"
Creating container "backend"
```

### 6.2 注册到中心机

**方式 1：手动 curl**
```bash
curl -X POST http://center-server:8000/api/v1/targets/register \
  -H "Content-Type: application/json" \
  -d '{"ip": "10.0.0.11"}'
```

**方式 2：脚本自动注册**
```bash
# 在客户机启动脚本中添加
CLIENT_IP=$(hostname -I | awk '{print $1}')
curl -X POST http://center-server:8000/api/v1/targets/register \
  -H "Content-Type: application/json" \
  -d "{\"ip\": \"${CLIENT_IP}\"}"
```

### 6.3 验证运行状态

**检查容器状态：**
```bash
docker-compose ps
```

**检查 Go Backend 接口：**
```bash
# 测试 Falco 接口
curl http://localhost:8888/falco | jq '.total'

# 测试 Filebeat 接口
curl http://localhost:8888/filebeat | jq '.total'

# 测试 Suricata 接口
curl http://localhost:8888/suricata | jq '.total'
```

**检查 RabbitMQ 队列：**
```bash
docker exec rabbitmq rabbitmqctl list_queues
```

**预期输出：**
```
data.falco     0
data.filebeat  0
data.suricata  0
```

### 6.4 常见问题排查

**问题 1：Go Backend 无法连接 RabbitMQ**
```bash
# 检查 RabbitMQ 是否健康
docker exec rabbitmq rabbitmq-diagnostics -q ping

# 检查网络连接
docker exec backend ping rabbitmq
```

**问题 2：Falco 传感器无输出**
```bash
# 检查 Falco 日志
docker logs falco

# 检查 Falco-ecs 是否正在读取
docker logs falco-ecs
```

**问题 3：接口返回空数据**
```bash
# 检查 RabbitMQ 队列是否有消息
docker exec rabbitmq rabbitmqctl list_queues

# 触发一些测试事件
docker exec falco ls /tmp
ping -c 3 8.8.8.8
```

---

## 7. 与中心机的交互

### 7.1 注册接口调用

**中心机调用：** `POST /api/v1/targets/register`

**客户机侧：** 无需实现，客户机只负责被动被轮询

> 备注：中心机同时提供完整版注册接口 `POST /api/v1/clients/register`（见 `docs/54-客户机-中心机接口规范.md`），
> 课程演示/快速接入可直接使用简化版 `targets/register`（只填 IP，由中心机推导 `listen_url`）。

### 7.2 轮询接口调用

**中心机每 5 秒轮询一次：**
```python
# 中心机 client_poller.py（示意）
async def _poll_client(http, listen_url, routes):
    for route in routes:  # ["falco", "filebeat", "suricata"]
        url = f"{listen_url.rstrip('/')}/{route}"
        response = await http.get(url)
        events = response.json()["data"]
        store_events(events)  # 存入 OpenSearch
```

**客户机响应：**
```json
{
  "total": 120,
  "data": [
    // ECS 文档列表
  ]
}
```

**幂等保证：**
- **拉取幂等**：RabbitMQ ACK 机制，消息被消费后不会再次出现
- **事件幂等**：中心机基于 `event.id` 去重（相同 ID 覆盖写入）

---

## 8. 性能与资源限制

### 8.1 RabbitMQ 队列配置

- **持久化**：`durable=True`（队列持久化到磁盘）
- **无消息过期**：消息永久保留，直到被消费
- **无队列长度限制**：默认不限制，可承载高吞吐量

### 8.2 Go Backend 资源限制

**建议配置：**
```yaml
backend:
  deploy:
    resources:
      limits:
        memory: 512M
      reservations:
        memory: 256M
```

**FetchAll() 行为：**
- 一次性拉取队列中所有消息
- 建议监控：单次拉取超过 10000 条消息时可能触发 OOM
- 缓解措施：RabbitMQ 队列本身作为缓冲，传感器写入速度有限

### 8.3 传感器性能

| 传感器 | CPU 占用 | 内存占用 | 吞吐量估算 |
|--------|---------|---------|-----------|
| Falco | 低（事件驱动） | ~100MB | ~100 events/s |
| Filebeat | 低 | ~50MB | ~50 logs/s |
| Suricata | 中（网络包处理） | ~500MB | ~1000 pkts/s |

---

## 9. 安全与审计

### 9.1 运行环境

- **网络**：靶场内网，可信环境
- **无鉴权**：Go Backend 接口无需认证
- **无加密**：HTTP 明文传输

### 9.2 数据留痕

所有事件必须包含：
- `event.id`：全局唯一，可追溯
- `@timestamp`：事件发生时间
- `host.id` + `host.name`：来源主机
- `message`：人类可读的事件描述

---

## 10. 扩展性考虑

### 10.1 新增传感器

如需新增数据源（例如进程注入检测、文件完整性监控）：

1. **创建新容器**：参考 `suricata-exporter` 结构
2. **输出到新队列**：例如 `data.yara`
3. **在 Go Backend 添加新路由**：
   ```go
   registerEventsRoute(r, "/yara", client, "data.yara")
   ```
4. **在中心机 poller.py 添加新路由**：
   ```python
   routes = ["falco", "filebeat", "suricata", "yara"]
   ```

### 10.2 水平扩展

客户机本身不支持多实例（单机部署）。如需采集更多主机：

- **部署多台客户机**：每台主机运行一套客户机组件
- **中心机轮询多个 IP**：在 `registry.py` 中注册多个 IP
- **OpenSearch 汇聚**：所有客户机的事件写入同一个 OpenSearch 集群

---

## 11. 技术债务与改进方向

### 11.1 已知限制

1. **Go Backend 无并发控制**：多个中心机同时拉取可能导致竞争（ACK 后消息被删除）
2. **无监控指标**：无法实时查看队列深度、消费速率等
3. **错误处理简单**：传感器故障时可能丢失数据

### 11.2 未来改进方向

1. **添加监控接口**：
   ```go
   r.GET("/metrics", func(c *gin.Context) {
       c.JSON(200, gin.H{
           "queues": map[string]int{
               "data.falco": getQueueDepth("data.falco"),
               "data.filebeat": getQueueDepth("data.filebeat"),
               "data.suricata": getQueueDepth("data.suricata"),
           },
           "uptime": time.Since(startTime).Seconds(),
       })
   })
   ```

2. **优雅退出**：处理 SIGTERM 信号，确保队列消息不丢失

3. **日志结构化**：使用结构化日志（JSON）便于调试

---

## 12. 相关文件清单

| 路径 | 说明 |
|------|------|
| `client/docker-compose.yml` | 容器编排配置 |
| `client/backend/main.go` | Go Backend 入口 |
| `client/backend/queue/client.go` | RabbitMQ 消费逻辑 |
| `client/sensor/falco/ecs-converter/falco_json_to_ecs.py` | Falco → ECS 转换 |
| `client/sensor/filebeat/detector.py` | Filebeat 日志采集 |
| `client/sensor/suricata/exporter/app.py` | Suricata EVE → ECS 转换 |
| `client/.env.example` | 环境变量模板 |
