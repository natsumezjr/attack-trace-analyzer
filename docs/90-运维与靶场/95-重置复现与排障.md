# 重置复现与排障

本文件给出靶场的固定重置步骤、固定复现步骤与固定排障顺序，保证每次演示从干净状态开始。

## 0. 固定变量

本文件命令默认在靶场宿主机执行，并使用以下固定变量：

```bash
export BASE=/home/ubuntu/attack-trace-analyzer
export REPO="$BASE"/repo/attack-trace-analyzer
```

## 1. 重置（固定步骤）

### 1.1 停机（固定）

1. 停止前端（运行 `npm run dev` 的终端按 `Ctrl+C`）
2. 停止后端（运行 `uvicorn` 的终端按 `Ctrl+C`）
3. 停止 4 套客户机容器
4. 停止 C2 容器
5. 停止中心机依赖并清空存储

```bash
for i in 01 02 03 04; do
  cd "$BASE"/run/client-$i
  docker-compose -p client-$i down
done

docker rm -f c2-dns c2-http || true

cd "$REPO"/backend
docker-compose down -v
```

### 1.2 清理数据（固定）

清理客户机数据目录（清空 Falco/Filebeat/Suricata 输出与状态文件）：

```bash
for i in 01 02 03 04; do
  rm -rf "$BASE"/run/client-$i/data/*
done
```

重置 C2 静态内容（保留网络与容器配置口径）：

```bash
rm -rf "$BASE"/run/c2/html/*
printf "ok\n" > "$BASE"/run/c2/html/health
printf "hello from c2 (benign)\n" > "$BASE"/run/c2/html/payload
```

通过标准（固定）：

- `"$BASE/run/client-01/data"` 到 `"$BASE/run/client-04/data"` 目录为空；
- `"$BASE/run/c2/html/health"` 与 `"$BASE/run/c2/html/payload"` 文件存在且内容可读。

## 2. 复现（固定步骤）

复现步骤固定为：

1. 按 `92-一键编排.md` 启动全部服务；
2. 按 `93-C2部署与证据点.md` 执行 DNS 与 HTTP 两条证据命令；
3. 按 `94-验证清单.md` 完成网络、采集、入库与证据点验证。

## 3. 排障顺序（固定）

排障严格按以下顺序执行，不允许跳步：

1. **后端健康检查**：`curl -sS http://localhost:8001/health` 返回 `{"status":"ok"}`  
2. **OpenSearch 可用**：`curl -k -u admin:OpenSearch@2024!Dev https://localhost:9200/_cluster/health` 的 `status` 为 `yellow|green`  
3. **C2 可用**：`dig @10.92.35.50 c2.lab.local +short` 返回 `10.92.35.51`，且 `curl -s http://10.92.35.51/health` 返回 `ok`  
4. **客户机接口可用**：`curl -sS http://10.92.35.13:18881/suricata` 返回 JSON 且包含 `total`  
5. **注册表可见**：`curl -sS http://localhost:8001/api/v1/clients` 的结果包含 `client-01..04`  
6. **Suricata 输出存在**：`"$BASE/run/client-01/data/eve.json"` 文件存在且文件大小大于 0

当上述任一项不满足时，直接在该项对应的组件上定位问题，不进入下一项。

## 4. 常见问题与解决方案

### 4.1 容器名称冲突（`Cannot create container for service rabbitmq: Conflict`）

**问题**：多个 client 实例启动时，容器名称冲突。

**原因**：多个实例使用相同的 docker-compose.yml，没有指定不同的项目名称。

**解决方案**：

1. 先停止所有冲突的容器：
   ```bash
   docker rm -f rabbitmq || true
   for i in 01 02 03 04; do
     cd "$BASE"/run/client-$i
     docker-compose -p client-$i down
   done
   ```

2. 使用 `-p` 参数指定项目名称重新启动：
   ```bash
   for i in 01 02 03 04; do
     cd "$BASE"/run/client-$i
     docker-compose -p client-$i up -d --build
   done
   ```

### 4.2 检查当前运行状态

```bash
# 检查所有client实例的容器
for i in 01 02 03 04; do
  echo "=== client-$i ==="
  docker ps --filter "name=client-$i" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
done

# 检查端口占用
ss -lntup | grep -E ':(18881|18882|18883|18884)\b'

# 检查中心机服务
ss -lntup | grep -E ':(9200|7474|7687|8001|3000)\b'
```

### 4.3 清理所有残留容器

如果遇到无法启动的情况，可以强制清理：

```bash
# 停止并删除所有client相关容器
for i in 01 02 03 04; do
  cd "$BASE"/run/client-$i
  docker-compose -p client-$i down -v
done

# 删除可能残留的容器
docker ps -a | grep -E 'client-|rabbitmq|falco|filebeat|suricata' | awk '{print $1}' | xargs -r docker rm -f
```
