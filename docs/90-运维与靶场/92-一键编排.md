# 一键编排

本文件给出靶场在单机上的固定启动顺序、固定命令与固定停机顺序，确保演示时“可启动、可验证、可重置”。

## 0. 固定变量

本文件命令默认在靶场宿主机执行，并使用以下固定变量：

```bash
export BASE=/home/ubuntu/attack-trace-analyzer
export REPO="$BASE"/repo/attack-trace-analyzer
```

## 1. 启动顺序（固定）

启动顺序固定为：

1. 启动中心机依赖（OpenSearch、Neo4j）
2. 启动 C2（macvlan 独立 IP）
3. 启动 4 套客户机采集栈（client-01..04）
4. 启动中心机后端（FastAPI）
5. 启动中心机前端（Next.js）
6. 注册 4 个客户机到中心机
7. 按验证清单执行一次闭环验证

## 2. 启动命令（固定）

### 2.1 启动中心机依赖（OpenSearch、Neo4j）

```bash
cd "$REPO"/backend
docker-compose up -d
```

### 2.2 启动 C2（DNS+HTTP）

按 `93-C2部署与证据点.md` 完成部署。该部署包含：

1. 创建 Docker macvlan 网络 `c2-macvlan`
2. 创建宿主机 `macvlan0` 并添加两条 `/32` 路由
3. 启动 `c2-dns` 与 `c2-http` 两个容器

### 2.3 启动 4 套客户机采集栈（client-01..04）

#### 2.3.1 准备 4 个实例运行目录（固定）

```bash
mkdir -p "$BASE"/run/client-{01,02,03,04}/data
```

#### 2.3.2 为每个实例放置 docker-compose.yml 与源码软链接（固定）

```bash
for i in 01 02 03 04; do
  cp "$REPO"/client/docker-compose.yml "$BASE"/run/client-$i/docker-compose.yml
  ln -snf "$REPO"/client/sensor "$BASE"/run/client-$i/sensor
  ln -snf "$REPO"/client/backend "$BASE"/run/client-$i/backend
done
```

#### 2.3.3 为每个实例写入 .env（固定）

```bash
cat > "$BASE"/run/client-01/.env <<'EOF'
CLIENT_API_PORT=18881
HOST_ID=h-client-01
HOST_NAME=victim-01
SURICATA_INTERFACE=macvlan0
EOF

cat > "$BASE"/run/client-02/.env <<'EOF'
CLIENT_API_PORT=18882
HOST_ID=h-client-02
HOST_NAME=victim-02
SURICATA_INTERFACE=macvlan0
EOF

cat > "$BASE"/run/client-03/.env <<'EOF'
CLIENT_API_PORT=18883
HOST_ID=h-client-03
HOST_NAME=victim-03
SURICATA_INTERFACE=macvlan0
EOF

cat > "$BASE"/run/client-04/.env <<'EOF'
CLIENT_API_PORT=18884
HOST_ID=h-client-04
HOST_NAME=victim-04
SURICATA_INTERFACE=macvlan0
EOF
```

#### 2.3.4 为每个实例修复 docker-compose.yml（固定）

**重要**：必须为每个服务添加 `container_name`，并为 backend 设置正确的端口映射，避免容器名称冲突和端口冲突。

```bash
for i in 01 02 03 04; do
  cd "$BASE"/run/client-$i
  
  python3 <<PYEOF
import yaml

with open('docker-compose.yml', 'r') as f:
    compose = yaml.safe_load(f)

project_name = 'client-$i'
port_map = {'01': '18881', '02': '18882', '03': '18883', '04': '18884'}
host_port = port_map['$i']

# 为每个服务添加container_name
for service_name, service_config in compose['services'].items():
    service_config['container_name'] = f"{project_name}_{service_name}_1"

# 修复backend的端口映射
if 'backend' in compose['services']:
    compose['services']['backend']['ports'] = [f"{host_port}:8888"]

# 移除rabbitmq的ports配置（如果存在，避免端口冲突）
if 'rabbitmq' in compose['services'] and 'ports' in compose['services']['rabbitmq']:
    del compose['services']['rabbitmq']['ports']

with open('docker-compose.yml', 'w') as f:
    yaml.dump(compose, f, default_flow_style=False, sort_keys=False, allow_unicode=True)

print(f"已修复 client-$i: container_name已添加，backend端口映射为 {host_port}:8888")
PYEOF
done
```

> **说明**：
> - 每个服务添加 `container_name` 确保容器名称唯一（如 `client-01_rabbitmq_1`、`client-02_rabbitmq_1`）
> - backend 端口映射使用环境变量对应的端口（18881-18884），避免端口冲突
> - rabbitmq 端口不映射到宿主机，仅在容器网络内部使用

#### 2.3.5 启动 4 个实例（固定）

**重要**：必须使用 `-p` 参数指定不同的项目名称，避免容器名称冲突。

```bash
for i in 01 02 03 04; do
  cd "$BASE"/run/client-$i
  docker-compose -p client-$i up -d --build
done
```

> **说明**：`-p client-$i` 参数为每个实例指定唯一的项目名称，确保容器名称不会冲突。例如 `client-01` 实例的容器名称会变成 `client-01_rabbitmq_1`、`client-01_falco_1` 等。

### 2.4 启动中心机后端（FastAPI）

在一个独立终端执行：

```bash
cd "$REPO"/backend
export OPENSEARCH_NODE="https://localhost:9200"
export OPENSEARCH_USERNAME="admin"
export OPENSEARCH_PASSWORD="OpenSearch@2024!Dev"
export OPENSEARCH_URL="https://localhost:9200"
export OPENSEARCH_USER="admin"
export NEO4J_URI="bolt://localhost:7687"
export NEO4J_USER="neo4j"
export NEO4J_PASSWORD="password"
uv sync
uv run uvicorn main:app --host 0.0.0.0 --port 8001
```

> **注意**：后端端口固定为 `8001`，避免与服务器上其他服务（如Django）的 `8000` 端口冲突。

### 2.5 启动中心机前端（Next.js）

在另一个独立终端执行：

```bash
cd "$REPO"/frontend
npm ci
npm run dev -- -H 0.0.0.0 -p 3000
```

### 2.6 注册 4 个客户机到中心机（固定）

```bash
curl -sS -X POST "http://localhost:8001/api/v1/clients/register" \
  -H "Content-Type: application/json" \
  -d '{"client_id":"client-01","client_version":"0.1.0","listen_url":"http://10.92.35.13:18881","host":{"id":"h-client-01","name":"victim-01"},"capabilities":{"filebeat":true,"falco":true,"suricata":true}}'

curl -sS -X POST "http://localhost:8001/api/v1/clients/register" \
  -H "Content-Type: application/json" \
  -d '{"client_id":"client-02","client_version":"0.1.0","listen_url":"http://10.92.35.13:18882","host":{"id":"h-client-02","name":"victim-02"},"capabilities":{"filebeat":true,"falco":true,"suricata":true}}'

curl -sS -X POST "http://localhost:8001/api/v1/clients/register" \
  -H "Content-Type: application/json" \
  -d '{"client_id":"client-03","client_version":"0.1.0","listen_url":"http://10.92.35.13:18883","host":{"id":"h-client-03","name":"victim-03"},"capabilities":{"filebeat":true,"falco":true,"suricata":true}}'

curl -sS -X POST "http://localhost:8001/api/v1/clients/register" \
  -H "Content-Type: application/json" \
  -d '{"client_id":"client-04","client_version":"0.1.0","listen_url":"http://10.92.35.13:18884","host":{"id":"h-client-04","name":"victim-04"},"capabilities":{"filebeat":true,"falco":true,"suricata":true}}'
```

每次注册成功必须返回 `status="ok"`。

## 3. 停机顺序（固定）

停机顺序固定为：

1. 停止前端（运行 `npm run dev` 的终端按 `Ctrl+C`）
2. 停止后端（运行 `uvicorn` 的终端按 `Ctrl+C`）
3. 停止 4 套客户机采集栈
4. 停止 C2
5. 停止中心机依赖（OpenSearch、Neo4j）

对应命令（固定）：

```bash
for i in 01 02 03 04; do
  cd "$BASE"/run/client-$i
  docker-compose -p client-$i down
done

docker rm -f c2-dns c2-http || true

cd "$REPO"/backend
docker-compose down
```

## 4. 下一步

验证与证据点检查清单见：

- `94-验证清单.md`
