# 模块与数据流说明（面向组员快速上手）

这份文档的目标很直接：让没有参与前期调研的同学也能从头到尾理解——数据从哪来、怎么走、每一段用什么技术、最后怎么拼成一条“攻击链”并展示给老师看。

## 1. 先把概念钉死：系统里只有两类东西在流动

为了避免把“日志、告警、图谱、攻击链”混在一起，我们把所有数据归为两类：

1) **事实事件（Events / Telemetry）**  
只描述“发生了什么”：进程启动、用户登录、DNS 查询、网络连接、文件读写……不做善恶判断，像“监控录像”。

2) **告警/发现（Findings / Alerts）**  
描述“哪些事实值得怀疑”：命中某条规则、严重程度如何、对应哪个 ATT&CK 技术点、为什么怀疑，像“警报器响”。

另外还有一个很实用的工程细分：

- **Raw Findings（原始告警）**：所有来源的告警先都收下，便于追溯
- **Canonical Findings（规范告警）**：把同一件事的重复告警合并成一条，后续串链主要吃这一层

> 注意：本文中出现的“用户/账号（user）”指 **被监控主机/域环境中的系统账号**（用于重建登录会话、横向移动等），不是本系统的登录账号；本系统默认单用户使用，不做账号/权限管理。

## 2. 从采集到溯源：按时间顺序讲清楚整条链路

下面按“真实工程流水线”顺序，从客户机侧采集开始讲。

### 2.1 客户机：三路采集 + 一个客户端后端

在靶场里你可以把每台被监控主机理解为“安装了传感器的取证现场”。本项目每台客户机包含 4 个组件：

1) **Wazuh（主机日志）**  
2) **Falco（主机行为告警）**  
3) **Suricata（网络流量与告警）**  
4) **客户端后端（Client Backend / Go）**：统一采集/归一化/缓冲/对外提供拉取接口

- **主机日志（系统审计/门禁记录）**  
  目的：回答“谁在什么时候登录、创建了什么进程、权限是否变化”。  
  技术选择：Wazuh（本项目主机日志采集只用 Wazuh）。

- **主机行为（贴身跟拍视角）**  
  目的：回答“哪个进程访问了什么文件、什么时候发起了网络连接”。  
  技术选择：Falco（本项目主机行为监控只用 Falco，输出行为告警为主）。  
  快速启动参考：`https://falco.org/docs/getting-started/falco-docker-quickstart/`  
  课程项目建议：不要做全量 syscall 入库，优先用 Falco 的规则告警作为“主机行为”信号来源。

- **网络流量（路口监控与会话还原）**  
  目的：回答“谁连了谁、DNS 查了什么、HTTP/TLS 会话特征如何”。  
  技术选择：Suricata（本项目网络流量只用 Suricata；EVE JSON 同时产出 flow/dns/http… + alert）。

到这里为止，客户机端会持续产生两类输出：

- 大量事实事件（telemetry）
- 少量告警（alerts）

### 2.2 客户端后端（Go）：归一化 + 缓冲 + 注册 + 被轮询

客户端后端的职责不是做深度分析，而是把数据可靠送到中心机，并保证后续能“串链”：

- **时间一致**：NTP/时区统一；输出统一时间格式
- **范式统一**：把不同格式映射到同一套字段（ECS 子集 + `custom.*`；见 `docs/03A-ECS字段规范.md`）
- **本地缓冲**：中心机拉取变慢时，客户端能顶住（本项目采用 SQLite）
- **启动注册**：客户端启动后主动向中心机注册（告诉中心机“我是谁、我在哪、我有什么能力”）
- **提供拉取接口**：注册成功后，中心机通过轮询客户端后端接口拉取数据

接口规范见：`docs/03C-客户端中心机接口规范.md`

### 2.3 中心机：Next.js 全栈（注册表 + 轮询器 + 入库）

中心机以 **Next.js 全栈**为核心（既提供后端 API，也提供前端页面）。中心机做三件关键事：

1) **注册表（Registry）**：接收客户端注册，维护客户端清单（`client_id/listen_url/capabilities/last_seen/cursor` 等）  
2) **轮询器（Poller）**：按 interval 轮询客户端，拉取新事件/告警  
3) **入库与索引**：写入 OpenSearch（Telemetry/Findings/Chains…）并驱动后续检测/关联

### 2.4 中心落库：OpenSearch 作为“案卷库”

中心侧的 **OpenSearch** 承担“案卷库”的角色：

- **事实事件索引（ecs-events-\*）**：只存 ECS 化后的事实事件
- **原始告警索引（raw-findings-\*）**：存所有来源的告警（端侧产的 + 中心扫出来的）
- **规范告警索引（canonical-findings-\*）**：对 raw 告警融合去重后的“唯一信号”（本项目默认生成，用于串链）

之所以要把事实和告警分开，是因为：

- 量级差异大（事实远多于告警）
- 生命周期不同（事实可短保留，告警/攻击链要更久便于复盘）
- 避免“告警又触发告警”的递归误扫

### 2.5 检测：告警从哪来（两条路）

很多同学会问“告警是客户端产还是中心产？”答案是：两种都可以。

- **Detect-first（端侧/传感器直接产告警）**  
  Wazuh/Falco/Suricata 都可能直接产出 alerts（本项目先全收，统一为 Raw Findings）。

- **Store-first（中心侧在库里扫描产告警）**  
  中心侧使用 OpenSearch Security Analytics：从 `ecs-events-*` 读取事实事件，按 Sigma 规则持续检测，并把命中结果写回 `raw-findings-*`。

### 2.6 告警融合去重：把噪声变成置信度

Detect-first + Store-first 同时运行时，重复告警几乎不可避免。  
正确做法是：先把原始告警都收下，再生成一份“规范告警”（Canonical Findings）给后续串链用。

直觉理解：

- 同一件事被多个引擎同时看到，反而说明它更像真的（置信度加分）
- 但如果不融合去重，链条会被“重复节点”撑爆，图会变成毛线团

### 2.7 关联：实体抽取 → Neo4j 图谱

当你手里有了：

- 事实事件（OpenSearch）
- 规范告警（Canonical Findings）

就可以开始做“实体与关系抽取”：

- 从事实事件里抽实体：host/user/process/file/ip/domain（session 为派生概念）…
- 从事实事件里抽关系：父子进程、登录会话、进程访问文件、进程发起连接、DNS 指向域名、域名解析到 IP…
- 把规范告警当作“标签/线索”：给某些节点/边标注 ATT&CK 技术点（例如 C2 外联）

实现上采用 Neo4j 作为实体关系图的权威存储，用于多跳路径推理与图展示。

### 2.8 串链：把“线索”拼成“故事”

最后一步才是老师最关心的“溯源能力”：

- 以规范告警作为链条种子
- 按时间排成线、按实体连成图
- 加上时间窗约束（例如 5–20 分钟）控制因果可信度
- 在图上找路径：初始入侵 → 执行 →（可选：持久化/提权）→ 横向移动 → C2 → 外传

输出给老师看的不应该是一堆日志，而是：

- 一张时间线（每步一句话 + tactic/technique）
- 一张关系图（实体与边）
- 一套证据回放（每步能回指到原始事实事件）
- 一份 ATT&CK 覆盖可视化（Navigator layer）

## 3. 全流程技术名词（按流水线顺序串起来）

`Wazuh/Falco/Suricata（采集） → 客户端后端（ECS 归一化 + 注册 + 缓冲 + API） → 中心机 Next.js（注册表 + 轮询拉取） → OpenSearch（Telemetry/Raw Findings） → Security Analytics + Sigma（Store-first） → Raw→Canonical（告警融合） → Neo4j（实体关系图） + 关联算法（攻击链重建） → Next.js 前端展示/导出（时间线/图/报告/Navigator layer）`
