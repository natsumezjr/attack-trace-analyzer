# 客户机 ↔ 中心机接口规范（v1）

## 0. 文档定位

本文只定义“客户机与中心机之间”的接口与协议：

- 客户机启动后向中心机注册；
- 中心机定时轮询客户机拉取数据（带游标与幂等语义）。

字段口径见 `51-ECS字段规范.md`，中心机流水线机制见 `30-系统规格说明书.md`。

## 1. 总体约定（固定）

### 1.1 API 版本与内容类型

- API 版本固定为 `v1`，体现在路径 `/api/v1/...`。
- 所有请求与响应的 `Content-Type` 固定为 `application/json; charset=utf-8`。

### 1.2 鉴权（Bearer token）

1) 客户机注册成功后，中心机下发 `client_token`。  
2) 中心机轮询客户机时必须携带 Header：

```
Authorization: Bearer <client_token>
```

客户机必须校验该 token，校验失败必须返回 `401`。

### 1.3 幂等与去重

- 事件幂等键为 `event.id`（见 `51-ECS字段规范.md`）。
- 拉取幂等通过 `cursor` 保证：中心机用上次的 cursor 拉取，客户机只返回 cursor 之后的新数据。

## 2. 中心机接口：客户机注册

### 2.1 `POST /api/v1/clients/register`

#### Request Body（固定结构）

```json
{
  "client_id": "client-victim-01",
  "client_version": "0.1.0",
  "listen_url": "http://10.0.0.11:8888",
  "host": {
    "id": "h-1111111111111111",
    "name": "victim-01"
  },
  "capabilities": {
    "filebeat": true,
    "falco": true,
    "suricata": true
  }
}
```

约束：

- `listen_url` 必须以 `http://` 或 `https://` 开头；
- `client_id` 必须稳定不变；
- `host.id` 与 `host.name` 必须稳定不变；
- `capabilities` 必须如实反映客户机侧可提供的三类数据源。

#### Response Body（固定结构）

```json
{
  "status": "ok",
  "client_token": "ata_xxx",
  "poll_interval_seconds": 5,
  "server_time": "2026-01-13T12:00:00.000Z"
}
```

约束：

- `poll_interval_seconds` 必须等于中心机环境变量 `CENTER_POLL_INTERVAL_SECONDS` 的实际取值；
- 中心机必须把注册信息写入 OpenSearch `client-registry`（OpenSearch 不可用时，中心机必须写入进程内内存注册表并在响应中附带 warning 字段）。

## 3. 客户机接口：中心机轮询拉取

### 3.1 `POST /api/v1/pull`

#### 3.1.1 设计目标

该接口必须满足：

- 支持游标拉取（避免重复拉取全表）；
- 支持三路数据并行拉取（filebeat / falco / suricata）；
- 返回 ECS 文档（中心机可直接入库 OpenSearch）。

#### 3.1.2 Request Body（固定结构）

```json
{
  "cursor": "{\"filebeat\":0,\"falco\":0,\"suricata\":0}",
  "limit_per_source": 500
}
```

字段说明：

- `cursor`：JSON 字符串，表示每个来源表的“已拉取最大 row_id”。
- `limit_per_source`：每个来源表返回的最大条数，取值范围 1–2000。

#### 3.1.3 Response Body（固定结构）

```json
{
  "status": "ok",
  "server_time": "2026-01-13T12:00:00.000Z",
  "next_cursor": "{\"filebeat\":120,\"falco\":33,\"suricata\":98}",
  "data": {
    "filebeat": {
      "items": [ { "ecs": { "version": "9.2.0" }, "event": { "id": "evt-..." } } ],
      "max_row_id": 120
    },
    "falco": {
      "items": [],
      "max_row_id": 33
    },
    "suricata": {
      "items": [],
      "max_row_id": 98
    }
  }
}
```

约束：

- `next_cursor` 必须与 `data.<source>.max_row_id` 一致；
- 当某个来源表无新数据时：
  - `items` 必须为空数组
  - `max_row_id` 必须等于请求 cursor 中该来源的值
- 客户机返回的 `items[]` 必须已经满足 `51-ECS字段规范.md` 的公共字段要求，尤其是：
  - 三时间字段存在
  - `event.kind` 与 `event.dataset` 正确
  - `event.id` 稳定

#### 3.1.4 客户机侧 cursor 语义（固定）

客户机侧 SQLite 表结构统一为：

- `id INTEGER PRIMARY KEY AUTOINCREMENT`
- `event_json TEXT NOT NULL`

客户机必须按以下规则处理 cursor：

- 请求 cursor 中每个来源表的值为 `last_id`；
- 查询时只返回 `id > last_id` 的记录；
- 返回的 `max_row_id` 为本次响应内该来源表返回记录的最大 `id`；当无返回记录时，`max_row_id = last_id`。

#### 3.1.5 客户机侧 ECS 补齐（固定）

客户机从 SQLite 读出 `event_json` 后，必须做如下补齐/规范化：

1) 将 JSON 解析为对象；  
2) 补齐 `host.id` 与 `host.name`（来自注册信息与环境变量）；  
3) 补齐 `event.id`（按 `51-ECS字段规范.md` 0.5.2 的规则，使用 `client_id/source_table/row_id`）；  
4) 补齐/规范化 `event.kind` 与 `event.dataset`（按 51 的命名体系）；  
5) 规范化三时间字段（按 51 的规则）；  
6) 确保输出 JSON 结构为“嵌套对象优先”。

## 4. 错误码与重试语义

### 4.1 统一错误响应

错误响应固定形态为：

```json
{
  "status": "error",
  "error": {
    "code": "BAD_REQUEST",
    "message": "..."
  }
}
```

### 4.2 关键错误码

- `400 BAD_REQUEST`：请求体缺失字段、cursor JSON 无法解析、limit 超范围
- `401 UNAUTHORIZED`：token 校验失败
- `503 SERVICE_UNAVAILABLE`：SQLite 不可读、数据库锁超时、内部依赖失败

### 4.3 重试语义（中心机侧）

中心机轮询失败时必须：

1) 将错误写入注册表 `poll.last_error`；  
2) 不推进该客户机 cursor；  
3) 在下一次 tick 继续重试；  
4) 不得因为单个客户机失败阻塞其它客户机的拉取与后续流程。
