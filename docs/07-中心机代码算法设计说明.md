# 代码设计说明报告（当前版本）

> 目标：说明目前代码中**每一个类与函数**的主要设计思路、职责边界、数据流走向，以及隐含假设与局限。

---

## 0. 总体架构概览

当前工程大体分为三层：

1. **图数据库访问层（Neo4j Repo/DAO）**
   - 负责：连接、建表/索引、节点/边的写入与读取、告警边查询、ECS事件落库。
   - 典型文件：`graph/db.py`（你贴的 neo4j 代码段）

2. **攻击状态机层（AttackFSA / NFA-FSA）**
   - 负责：把异常边按时间序列映射到 ATT&CK 战术状态，并按状态转移规则形成“被接受的攻击路径骨架”（仅核心证据序列）。
   - 典型文件：`attack_fsa.py`

3. **分析流水线层（Pipeline）**
   - 负责：数据拉取 -> 初步子图聚合 -> 子图补全 -> 溯源最大风险路径 -> 向量提取/匹配 -> LLM解释。
   - 典型文件：pipeline 段落（含 `Subgraph/CallChain/backtrack_call_chain/run_analysis_pipeline` 等）

---

## 1. 图数据库访问层（Neo4j）设计说明

### 1.1 全局变量
- **`_DRIVER`**
  - 设计意图：缓存 Neo4j Driver（单例），避免重复建立连接。
  - 特点：懒加载，首次使用才初始化。

- **`_SCHEMA_READY`**
  - 设计意图：schema/索引只创建一次，避免每次写入都跑建表语句。
  - 特点：进程内布尔标记（非跨进程）。

---

### 1.2 连接与会话管理

#### `_get_driver()`
- 职责：构造并缓存 Neo4j driver。
- 设计点：
  - 从环境变量读取 `NEO4J_URI/USER/PASSWORD`，默认本地 bolt。
  - 返回同一个 driver 实例（简单单例模式）。

#### `_get_session()`
- 职责：获得一个 session。
- 设计点：
  - 支持指定 `NEO4J_DATABASE`，兼容 Neo4j 多数据库。

#### `_execute_write(session, func, *args, **kwargs)`
#### `_execute_read(session, func, *args, **kwargs)`
- 职责：兼容 neo4j Python driver 不同版本：
  - 新版用 `execute_write/execute_read`
  - 老版用 `write_transaction/read_transaction`
- 设计意图：避免依赖特定 driver 版本，提升可移植性。

---

### 1.3 Cypher 参数与命名安全辅助

#### `_param_key(name: str) -> str`
- 职责：将属性名映射为安全参数名（只允许字母数字与下划线）。
- 设计意图：避免属性名含 `.` 或特殊字符导致 Cypher 参数不合法。

#### `_cypher_prop(name: str) -> str`
- 职责：对属性名进行 Cypher 反引号转义。
- 设计意图：允许使用诸如 `host.id` 这种带点的属性名作为 Neo4j 属性字段。

#### `_name_suffix(name: str) -> str`
- 职责：生成可用于 constraint/index 名称的安全后缀。
- 设计意图：neo4j constraint/index 名称不宜包含特殊字符。

---

### 1.4 Schema 创建与保障

#### `ensure_schema() -> None`
- 职责：确保 schema（唯一约束/索引）已创建。
- 设计意图：把 schema 创建与业务写入解耦，且只做一次。

#### `_create_schema(tx) -> None`
- 职责：创建约束与索引（IF NOT EXISTS）。
- 设计意图：
  - “唯一约束”用于关键实体去重（Host/User/Process/File/Domain/IP/NetConn 等）。
  - “索引”用于常用字段加速查询。

---

### 1.5 写入：节点与边

#### `add_node(node: GraphNode) -> None`
- 职责：对外写节点入口。
- 设计点：内部确保 schema，再执行 merge。

#### `_merge_node(tx, node: GraphNode) -> None`
- 职责：MERGE 节点 + SET 属性。
- 设计意图：
  - **用 node.key 作为唯一键**做 MERGE。
  - **用 merged_props**把 props 合并写入。
  - MERGE 保证幂等写入。

#### `add_edge(edge: GraphEdge) -> None`
- 职责：对外写边入口。

#### `_create_edge(tx, edge: GraphEdge) -> None`
- 职责：确保端点存在 + 创建关系边。
- 设计意图：
  - `parse_uid` 解析出 `src_label/src_key`，`dst_label/dst_key`。
  - `MERGE` 两端节点（避免 dangling nodes）。
  - `CREATE` 关系（注意：这里不是 MERGE 关系，会导致重复边可能出现）。
  - `SET r += props` 写入关系属性。

> 局限：关系使用 CREATE 不去重；如果同一边写入多次会产生多条关系。

---

### 1.6 读取：节点、边、告警边

#### `get_node(uid: str) -> GraphNode | None`
- 职责：按 uid 找节点。
- 设计意图：
  - `parse_uid` 决定 label 与 key。
  - 查询返回 properties(n)，再把 key 字段剔除后作为 props。

#### `_fetch_node(tx, label: NodeType, key: dict[str, Any])`
- 职责：执行 MATCH 查询并返回节点属性。

#### `get_edges(node: GraphNode) -> list[GraphEdge]`
- 职责：取与该节点相连的所有关系（无方向过滤）。
- 设计点：
  - Cypher `MATCH (n)-[r]-(m)` 返回任意方向关系。
  - 用 `labels(startNode(r))/endNode(r)` 重构 src/dst。
  - 用 `_node_uid_from_record` 从 props 推导 uid。

#### `_fetch_edges(tx, node: GraphNode)`
- 职责：执行边查询并返回原始记录集。

#### `get_alarm_edges() -> list[GraphEdge]`
- 职责：取全图中标记为 `is_alarm=true` 的关系边。
- 设计意图：提供统一“告警边入口”，供上层 pipeline 使用。

#### `_fetch_alarm_edges(tx)`
- 职责：执行告警边查询。

---

### 1.7 UID 推导辅助

#### `_node_uid_from_record(labels, props) -> str | None`
- 职责：从 Neo4j 返回的 labels/props 还原内部 uid。
- 设计意图：
  - 优先用 `NODE_UNIQUE_KEY` 指定的唯一字段生成 uid。
  - 否则 fallback 到一组候选字段（例如 file.path / file.hash.*）。
  - 解决 Neo4j 节点属性不完整或不统一时的兜底。

#### `_label_to_ntype(labels) -> NodeType | None`
- 职责：labels 列表映射为内部 NodeType。

#### `_fallback_key(ntype, props) -> dict | None`
- 职责：提供不同节点类型的候选唯一字段集合。

---

### 1.8 生命周期与数据摄取

#### `close() -> None`
- 职责：关闭 driver，清理全局缓存。

#### `ingest_ecs_event(event) -> tuple[int, int]`
- 职责：单条 ECS event 转图（nodes/edges）并写入。
- 设计意图：把“解析 ECS -> GraphNode/GraphEdge”交给 `ecs_event_to_graph`，DAO 只负责落库。

#### `ingest_ecs_events(events) -> tuple[int, int]`
- 职责：批量摄取，累计计数返回。

---

## 2. 攻击状态机层（attack_fsa.py）设计说明

### 2.1 `AttackState(Enum)`
- 职责：定义 MITRE ATT&CK tactic 战术阶段。
- 设计意图：
  - 用字符串值保持与外部/数据库标签一致（例如 tactic.name 的空格格式）。
  - 既包含你强调的“核心6个状态”，也包含其它战术（用于映射/兼容）。

---

### 2.2 `STATE_TRANSITIONS`
- 职责：定义状态机转移规则（from_state -> allowed_to_set）。
- 设计意图：
  - “现实攻击链存在跳跃/缺失”因此允许部分跨阶段跳转。
  - 以集合表达允许后继，便于快速 membership 判断。

### 2.3 `ALLOW_SELF_LOOP`
- 职责：控制是否允许同一状态内自环。
- 设计意图：
  - 同一阶段可能出现多条相似告警（连续 beacon），允许自环可减少无谓分叉。

---

### 2.4 `_EdgeLike`（鸭子类型接口）
- 职责：约束输入边对象至少具备：
  - `get_attack_tag()`
  - `get_ts()`
- 设计意图：
  - 降低对 GraphEdge 的强耦合（允许传入类似结构对象）。
  - 在你的工程里 GraphEdge 实际会提供这些方法或可扩展。

> 局限：目前实现里方法签名有一点混乱（函数参数 edge: GraphEdge 但实例方法却使用 self/edge），属于“示例性”接口。

---

### 2.5 路径输出结构

#### `TransitionStep`
- 字段：
  - `state: AttackState`
  - `edge: _EdgeLike`
- 设计意图：把“状态”与“证据边”绑定，成为路径的基本单元。

#### `AttackPath`
- 字段：`steps: List[TransitionStep]`
- 方法：
  - `states()`：提取状态序列
  - `edges()`：提取证据边序列
  - `last_state()`：取末状态
- 设计意图：
  - 作为“被状态机接受的一条 killchain 骨架”输出结构，主要服务上层可视化/解释。

---

### 2.6 `TAG_TO_STATE`
- 职责：将数据库或边属性里的 `attack_tag` 映射为 AttackState。
- 设计意图：
  - 同时兼容“无空格内部写法”（InitialAccess）与“MITRE空格写法”（Initial Access）。

#### `_edge_to_state(edge) -> Optional[AttackState]`
- 职责：根据 edge.get_attack_tag() 查表映射为 state。
- 设计意图：把映射逻辑集中，避免散落。

---

### 2.7 `AttackFSA`（核心自动机类）

#### `__init__(accept_states=None, max_backtrack=10)`
- 状态：
  - `current_state: Optional[AttackState]`
  - `accept_states: Set[AttackState]`
  - `max_backtrack: int`
- 设计意图：
  - accept_states 可配置（默认 Exfiltration）。
  - max_backtrack 控制回溯深度上限。

#### `add_accept_state(s)`
#### `set_accept_states(states)`
- 职责：提供接受态集合的可配置接口。

#### `can_transition(from_state, to_state) -> bool`
- 设计意图：
  - `from_state is None`：允许从任意阶段开始（现实数据可能缺 InitialAccess）。
  - self-loop：由 `ALLOW_SELF_LOOP` 控制。
  - 其它：按 `STATE_TRANSITIONS` 判定。

#### `_try_backtrack(steps, next_state, n) -> bool`
- 职责：当无法转移时，尝试回溯 pop 若干 step，找到可接 next_state 的前缀。
- 设计意图：
  - 用“有限回溯”解决不一致序列（噪声/缺失导致的断链）。
  - 回溯成功则 steps 被就地修改为回溯后的前缀。

#### `build_accepted_paths(error_edge_list) -> List[AttackPath]`
- 职责：对外接口：输入异常边列表，输出被接受的 AttackPath 列表。
- 核心流程设计：
  1. 按 `ts` 排序
  2. 逐条映射到 state
  3. 可转移则 append，否则尝试回溯；回溯失败则丢弃该边
  4. 当到达 accept_state 时输出一条 AttackPath，并重置 steps
- 设计意图：
  - “接受态驱动输出”：只有达到终止/接受阶段才认为形成一条链路。
  - “丢弃策略”：无法接入则认为是干扰项，跳过。

> 局限：当前实现只有单路径回溯，不会保留多分支并行假设（你后续已经提出要同时保留 pop 与 drop 的分支）。

---

## 3. Pipeline / 溯源分析层设计说明

### 3.1 `Subgraph`
- 字段：
  - `nodes: dict[uid, GraphNode]`
  - `edges: list[GraphEdge]`
  - `_incoming_index: dict[dst_uid, list[GraphEdge]]`
- 方法：
  - `add_node(node)`：加入节点
  - `add_edge(edge)`：加入边，并维护入边索引
  - `get_node(uid)`：O(1)取节点
  - `get_incoming_edges(node_uid)`：O(1)取入边列表（用于回溯/DP）
- 设计意图：
  - “空间换时间”：把相关子图一次性拉入内存并建索引，支持快速 predecessor 查询。
  - `_incoming_index` 明确针对“回溯溯源”这一需求（找前驱边）。

---

### 3.2 `CallChain`
- 字段：`chain: list[GraphEdge]`
- 属性：`length`
- 设计意图：
  - 作为“最终攻击路径”的纯数据容器，不关心算法过程。
  - 路径用边序列表达，节点信息隐含在边端点中。

---

### 3.3 Pipeline 阶段函数（编排）

#### `fetch_edges_from_db() -> tuple[list[GraphEdge], list[GraphEdge]]`
- 职责：数据获取层占位（目前返回空）。
- 设计意图：未来应从 Neo4j / ES / 文件中加载 normal/abnormal 边集合。

#### `behavior_state_machine(normal_edges, abnormal_edges) -> list[Subgraph]`
- 职责：根据边的时序与实体关联把异常聚成多个 Subgraph（当前是示例逻辑：每条异常边一个 subgraph）。
- 设计意图：
  - 把“状态机/聚类”与“溯源分析”分层，先形成候选子图，再做补全与溯源。

> 局限：目前实现仅示例，没做实体关联、时间窗口聚合、节点拉取等。

#### `expand_to_complete_subgraph(subgraph: Subgraph) -> Subgraph`
- 职责：补全子图：把缺失的关联边查回并加到 subgraph。
- 设计意图：
  - 通过 DB 查找 subgraph.nodes 内节点之间漏掉的边，增强连通性。
  - 为后续溯源（最大路径）提供足够的图结构。

> 局限：当前是空实现（仅返回原 subgraph）。

---

### 3.4 风险评分与语义向量化

#### `BASE_RISK_WEIGHTS: dict[RelType, float]`
- 职责：关系类型基础风险分。
- 设计意图：
  - 体现领域先验：例如 `SPAWN`/`NET_CONNECT` 风险高于 `RESOLVES_TO`。
  - 作为 LLM 分析的“底座”，最终分数由 base 与语义置信度融合。

#### `MockLLMClient.analyze_intent(src_context, action, dst_context) -> (float, vector)`
- 职责：模拟 LLM 语义判定与向量输出。
- 设计意图：
  - 将来可替换为真实 LLM/Embedding 服务。
  - 当前用简单规则（powershell、encoded）模拟高风险。

#### `_calculate_edge_weight_and_vector(edge, subgraph) -> (float, vector)`
- 职责：对一条边计算：
  - 威胁权重 weight
  - 行为向量 vector
- 设计意图：
  1. base_score：从 `BASE_RISK_WEIGHTS` 取
  2. 上下文：从 subgraph.get_node(src/dst) merged_props 提取
  3. LLM：返回置信度与向量
  4. 融合：`final_weight = base_score * (1 + llm_confidence)`
- 额外设计点：
  - 计算后把 `weight/vector` 写回 `edge.props`，便于后续复用（“边即载体”）。

---

### 3.5 溯源核心：`backtrack_call_chain(subgraph, alarm_edge=None) -> CallChain`

- 职责：从告警点（alarm_edge）出发，寻找一条“累计风险最高”的前驱路径。
- 设计意图：这是一个“最大风险路径（Critical Path）”问题。

主要步骤设计：

1. **告警锚点确定**
   - 若未指定 alarm_edge：选 ts 最新的一条边作为告警点。
   - 意图：提供默认告警锚点策略。

2. **DP/Memoization 容器**
   - `memo[edge_id] = (acc_score, path_edges)`
   - `recursion_stack` 用于环检测
   - 意图：避免重复子问题计算，防止递归环导致无限循环。

3. **递归函数 `get_max_risk_path_to(current_edge)`**
   - 当前边先算 weight/vector（并写回 props）
   - 找前驱：`incoming_candidates = subgraph.get_incoming_edges(current_edge.src_uid)`
   - 约束：
     - 时间单调：`prev_ts <= curr_ts + 0.1`
     - 时间跨度剪枝：大于 30 天剪掉
   - 从所有前驱中选 `prev_score` 最大的那条，形成 best_prev_path
   - 聚合：`total_score = max_prev_score + w`

4. **返回结果封装**
   - 输出 `CallChain(chain=best_chain_list)`

> 备注：虽然函数名叫 backtrack，但实现已经是“带缓存的递归DP”。你后续提出要改为“非回溯、显式DP + 复用缓存”，本质是在现有思想上做工程化与全局复用。

---

### 3.6 向量/匹配/LLM解释

#### `extract_vectors(chain: CallChain) -> list[list[float]]`
- 职责：把链路中的边转换为向量序列（目前是示例）。
- 设计意图：后续可接 embedding、手工特征、统计特征等。

#### `match_vector_features(vectors) -> dict[str, Any]`
- 职责：特征匹配/分类（目前示例返回固定结果）。
- 设计意图：可接规则库、相似度检索、模型推断。

#### `analyze_with_llm(match_result, chain) -> str`
- 职责：将匹配结果与链路转成自然语言解释（报告）。
- 设计意图：
  - Prompt = chain_desc（按时间列举边）
  - 输出：攻击类型 + 证据链描述

---

### 3.7 编排入口：`run_analysis_pipeline()`
- 职责：串联全部流程。
- 流程：
  1. fetch 数据
  2. 状态机/聚合成 subgraphs
  3. expand 补全
  4. backtrack 得到 call_chain
  5. 向量提取
  6. 匹配
  7. LLM 总结输出
- 设计意图：单一入口便于调试与演示（Main function）。

---

## 4. 当前设计的关键假设与局限总结

1. **状态机层目前是“单假设路径 + 回溯/丢弃”**
   - 不保留多分支并行结果。
   - 你后续要求的“pop与drop分支都保留并输出多图”尚未实现。

2. **Subgraph 的补全逻辑是占位**
   - 当前未真正从 DB 拉回缺失边，导致溯源链路受限于初始边集合。

3. **边关系写入未去重**
   - `CREATE (s)-[r]->(d)` 可能重复写入相同关系。

4. **风险评分/向量化是 mock**
   - `MockLLMClient` 与 `extract_vectors/match_vector_features` 均为示意实现。

---

## 5. 建议的阅读顺序（便于理解）

1. 先读 `run_analysis_pipeline` 看全流程
2. 再读 `Subgraph` 与 `backtrack_call_chain` 理解溯源DP
3. 再读 `AttackFSA.build_accepted_paths` 理解状态机抽链
4. 最后读 neo4j DAO（schema + merge + query）理解数据来源与结构

---
